<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/pokeball_menu.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/pokeball_menu.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录学习的点滴，每天一小步">
<meta name="keywords" content="Java、C++、Python、TensorFlow、Android">
<meta property="og:type" content="website">
<meta property="og:title" content="决斗者的学习博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="决斗者的学习博客">
<meta property="og:description" content="记录学习的点滴，每天一小步">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="决斗者的学习博客">
<meta name="twitter:description" content="记录学习的点滴，每天一小步">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>决斗者的学习博客</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6697a1363f65085bd28b3b4b490bdd74";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">决斗者的学习博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/tensorflow-compile1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="决斗者">
      <meta itemprop="description" content="记录学习的点滴，每天一小步">
      <meta itemprop="image" content="/images/yu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="决斗者的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/29/tensorflow-compile1/" class="post-title-link" itemprop="url">TensorFlowԴ�����</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-29 20:25:36 / 修改时间：23:37:25" itemprop="dateCreated datePublished" datetime="2019-05-29T20:25:36+08:00">2019-05-29</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="TensorFlowԴ�����"><a href="#TensorFlowԴ�����" class="headerlink" title="TensorFlowԴ�����"></a>TensorFlowԴ�����</h4><p>TensorFlow��ΪGoogle��AI����Ļ������л����������Ϊ�����ű��㷺�о�������ʹ��Mac��TensorFlowԴ����б��롣<br>1 ��װ��Ҫ������<br>1.1 ��װJDK 8<br>JDK 8 can be downloaded from Oracle��s JDK Page :<br>[��������] (<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)��" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)��</a><br>Look for ��Mac OS X�� under ��Java SE Development Kit��.<br>This will download a DMG image with an install wizard��<br>1.2 ��װHomebrew<br>Install Homebrew on macOS (OS X)��Installing Homebrew is a one-time setup:<br>$ ruby -e “(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a><br>1.3 ��װָ���汾Bazel: ��װ��װGoogle�Լҵı��빤��bazel��<br>mac����õİ취����ֱ��ʹ��brew��װ�ˣ� Install Bazel Homebrew Package��<br>brew install bazel<br>You are all set. You can confirm Bazel is installed successfully by running bazel version.<br>You can later upgrade to newer version of Bazel with brew upgrade bazel.<br>���ڲ�ͬ�汾��TensorFlowԴ�����Bazel�汾���Լ���Ҫ��<br>����ͨ�����·�ʽ��װָ���汾��Bazel:<br>�������<a href="https://docs.bazel.build/versions/master/install-os-x.html" target="_blank" rel="noopener">https://docs.bazel.build/versions/master/install-os-x.html</a><br>ִ�����<br>Step 1: Install Xcode command line tools<br>Xcode can be downloaded from the Apple Developer Site (this link redirects to their App Store).<br>For objc_<em> and ios_</em> rule support, you must have Xcode 6.1 or later with iOS SDK 8.1 installed on your system.<br>Once Xcode is installed, accept the license agreement for all users with the following command:<br>sudo xcodebuild -license accept</p>
<p>Step 2: Download the Bazel installer<br>Next, download the Bazel binary installer named bazel-<version>-installer-darwin-x86_64.sh<br>from the Bazel releases page on GitHub.</version></p>
<p>Step 3: Run the installer<br>Run the Bazel installer as follows:<br>chmod +x bazel-<version>-installer-darwin-x86_64.sh<br>./bazel-<version>-installer-darwin-x86_64.sh –user<br>The –user flag installs Bazel to the $HOME/bin directory on your system and sets the .bazelrc<br>path to $HOME/.bazelrc. Use the –help command to see additional installation options.</version></version></p>
<p>Step 4: Set up your environment<br>If you ran the Bazel installer with the –user flag as above, the Bazel executable is<br>installed in your $HOME/bin directory. It��s a good idea to add this directory to your default<br>paths, as follows:<br>export PATH=”PATH:PATH:PATH:HOME/bin”<br>You can also add this command to your ~/.bashrc or ~/.profile file.<br>All set! You can confirm Bazel is installed successfully by running the following command:</p>
<p>bazel version</p>
<p>1.4 Xcode��װ<br>������Mac����tensorflow��ҪXcode������<br>���ȴ����� <a href="https://developer.apple.com/download/more/" target="_blank" rel="noopener">https://developer.apple.com/download/more/</a> ����ҳ��<br><img src="/2019/05/29/tensorflow-compile1/tensorflow-compile/Image1.jpg" alt="Xcode���ؽ���"><br>��������������Xcode �س�����������ͼ��ʾ��<br><img src="/2019/05/29/tensorflow-compile1/tensorflow-compile/Image2.jpg" alt="Xcode���ؽ���"><br>�ҵ�����İ汾�����+�򿪣��鿴���飬�����������ء�<br>��ѹ��װ��<br>2 ��װtensorflow<br>2.1 ���عٷ���tensorflowԴ��<br>$ git clone <a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">https://github.com/tensorflow/tensorflow</a><br>2.2 ����<br>�������֮�����û�Ŀ¼������һ��tensorflow��Ŀ¼���������Ŀ¼��<br>./configure<br>�������ã������ù����л����һϵ�е����⣬ͨ�������û�������Ҫ��һ��ȫ����ѡ��n��<br>3 ����<br>������ɺ���Ǳ�������ˣ�������������(������������ᷢ����ĵ��Ժ������죬���һỨ�ϳ�ʱ��������)��<br>bazel clean –expunge<br>sudo xcode-select -s /Applications/Xcode.app/Contents/Developer ���ѡ��Xcode��Ŀ¼����Ҫ<br>sudo xcodebuild -license<br>bazel clean –expunge<br>bazel build -c opt //tensorflow:libtensorflow_cc.so<br>4 ���<br>�����bazel-bin��tensorflow������libtensorflow_cc.so��libtensorflow_framework.so�ļ���</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/c-language-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="决斗者">
      <meta itemprop="description" content="记录学习的点滴，每天一小步">
      <meta itemprop="image" content="/images/yu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="决斗者的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/18/c-language-learning/" class="post-title-link" itemprop="url">C、C++知识点总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-18 20:25:36 / 修改时间：20:29:33" itemprop="dateCreated datePublished" datetime="2019-05-18T20:25:36+08:00">2019-05-18</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="C、C-知识点总结"><a href="#C、C-知识点总结" class="headerlink" title="C、C++知识点总结"></a>C、C++知识点总结</h4><p><strong>const作用：</strong></p>
<ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针和指针常量；</li>
<li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ol>
<p><strong>const 使用：</strong></p>
<p>// 类class A<br>{<br>private:<br>    const int a;                // 常对象成员，只能在初始化列表赋值<br>public:<br>    // 构造函数<br>    A() : a(0) { };<br>    A(int x) : a(x) { };        // 初始化列表<br>    // const可用于对重载函数的区分<br>    int getValue();             // 普通成员函数<br>    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值<br>};</p>
<p>void function()<br>{<br>    // 对象<br>    A b;                        // 普通对象，可以调用全部成员函数<br>    const A a;                  // 常对象，只能调用常成员函数、更新常成员变量<br>    const A <em>p = &a;            // 常指针<br>    const A &amp;q = a;             // 常引用<br>    // 指针<br>    char greeting[] = “Hello”;<br>    char</em> p1 = greeting;                // 指针变量，指向字符数组变量<br>    const char<em> p2 = greeting;          // 指针变量，指向字符数组常量<br>    char</em> const p3 = greeting;          // 常指针，指向字符数组变量<br>    const char* const p4 = greeting;    // 常指针，指向字符数组常量<br>}</p>
<p>// 函数void function1(const int Var);           // 传递过来的参数在函数内不可变void function2(const char<em> Var);         // 参数指针所指内容为常量void function3(char</em> const Var);         // 参数指针为常指针void function4(const int&amp; Var);          // 引用参数在函数内为常量</p>
<p>// 函数返回值const int function5();      // 返回一个常数const int<em> function6();     // 返回一个指向常量的指针变量，使用：const int </em>p = function6();int<em> const function7();     // 返回一个指向变量的常指针，使用：int</em> const p = function7();</p>
<p><strong>static作用：</strong></p>
<ol>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ol>
<p><strong>this 指针：</strong></p>
<ol>
<li>this?指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给?this?指针，然后调用成员函数，每次成员函数存取数据成员时，都隐含使用?this?指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li>this?指针被隐含地声明为:?ClassName <em>const this，这意味着不能给?this?指针赋值；在?ClassName?类的?const?成员函数中，this?指针的类型为：const ClassName</em> const，这说明不能对?this?指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li>this?并不是一个常规变量，而是个右值，所以不能取得?this?的地址（不能?&amp;this）。</li>
<li>在以下场景中，经常需要显式引用?this?指针：<br>1） 为实现对象的链式引用；<br>2） 为避免对同一对象进行赋值操作；<br>3） 在实现一些数据结构时，如?list。</li>
</ol>
<p><strong>inline 内联函数作用：</strong></p>
<ol>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>
</ol>
<p><strong>inline 使用：</strong><br>// 声明1（加 inline，建议使用）inline int functionName(int first, int second,…);<br>// 声明2（不加 inline）int functionName(int first, int second,…);<br>// 定义inline int functionName(int first, int second,…) {/<em>**</em>/};<br>// 类内定义，隐式内联class A {<br>    int doA() { return 0; }         // 隐式内联<br>}<br>// 类外定义，需要显式内联class A {<br>    int doA();<br>}<br>inline int A::doA() { return 0; }   // 需要显式内联</p>
<p>编译器对 inline 函数的处理步骤：</p>
<ol>
<li>将 inline 函数体复制到 inline 函数调用点处；</li>
<li>为所用 inline 函数中的局部变量分配内存空间；</li>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>
</ol>
<p><strong>优缺点：</strong><br><strong>优点</strong></p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ol>
<p><strong>虚函数（virtual）可以是内联函数（inline）吗？</strong></p>
<ol>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li>inline virtual?唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如?Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ol>
<p><strong>虚函数内联使用：</strong></p>
<p>#include <iostream><br>using namespace std;class Base<br>{<br>public:<br>        inline virtual void who()<br>        {<br>                cout &lt;&lt; “I am Base\n”;<br>        }<br>        virtual ~Base() {}<br>};<br>class Derived : public Base<br>{<br>public:<br>        inline void who()  // 不写inline时隐式内联<br>        {<br>                cout &lt;&lt; “I am Derived\n”;<br>        }<br>};</iostream></p>
<p>int main()<br>{<br>        // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。<br>        Base b;<br>        b.who();<br>        // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。<br>        Base *ptr = new Derived();<br>        ptr-&gt;who();<br>        // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。<br>        delete ptr;<br>        ptr = nullptr;<br>        system(“pause”);<br>        return 0;<br>}</p>
<p><strong>volatile作用：</strong></p>
<ol>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ol>
<p><strong>assert()：</strong><br>断言，是宏，而非函数。assert 宏的原型定义在?&lt;assert.h&gt;（C）、<cassert>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义?NDEBUG?来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt;?之前。</cassert></p>
<p>#define NDEBUG          // 加上这行，则 assert 不可用</p>
<p>#include &lt;assert.h&gt;<br>assert( p != NULL );    // assert 不可用</p>
<p><strong>sizeof()：</strong></p>
<ol>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ol>
<p>#pragma pack(n)<br>设定结构体、联合以及类成员变量以 n 字节方式对齐</p>
<p>#pragma pack(push)  // 保存对齐状态</p>
<p>#pragma pack(4)     // 设定为 4 字节对齐<br>struct test<br>{<br>    char m1;<br>    double m4;<br>    int m3;<br>};</p>
<p>#pragma pack(pop)   // 恢复对齐状态</p>
<p><strong>位域：</strong><br>Bit mode: 2;    // mode 占 2 位<br>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p>
<ol>
<li>位域在内存中的布局是与机器有关的</li>
<li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li>
<li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li>
</ol>
<p><strong>extern “C”：</strong></p>
<ol>
<li>被 extern 限定的函数或变量是 extern 类型的</li>
<li>被?extern “C”?修饰的变量和函数是按照 C 语言方式编译和链接的<br>extern “C”?的作用是让 C++ 编译器将?extern “C”?声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</li>
</ol>
<p>extern “C” 使用：</p>
<p>#ifdef __cplusplus<br>extern “C” {</p>
<p>#endif<br>void <em>memset(void </em>, int, size_t);</p>
<p>#ifdef __cplusplus<br>}</p>
<p>#endif</p>
<p>struct 和 typedef struct：<br>C 中<br>// c<br>typedef struct Student {<br>    int age;<br>} S;<br>等价于// c<br>struct Student {<br>    int age;<br>};<br>typedef struct Student S;<br>此时?S?等价于?struct Student，但两个标识符名称空间不相同。另外还可以定义与?struct Student?不冲突的?void Student() {}。</p>
<p>C++ 中<br>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。<br>一、如果在类标识符空间定义了?struct Student {…};，使用?Student me;?时，编译器将搜索全局标识符表，Student?未找到，则在类标识符内搜索。<br>即表现为可以使用?Student?也可以使用?struct Student，如下：<br>// cpp<br>struct Student {<br>    int age;<br>};<br>void f( Student me );       // 正确，”struct” 关键字可省略<br>二、若定义了与?Student?同名函数之后，则?Student?只代表函数，不代表结构体，如下：<br>typedef struct Student {<br>    int age;<br>} S;</p>
<p>void Student() {}           // 正确，定义后 “Student” 只代表此函数</p>
<p>//void S() {}               // 错误，符号 “S” 已经被定义为一个 “struct Student” 的别名</p>
<p>int main() {<br>    Student();<br>    struct Student me;      // 或者 “S me”;<br>    return 0;<br>}</p>
<p><strong>C++ 中 struct 和 class</strong><br>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。<br><strong>区别</strong><br>最本质的一个区别就是默认的访问控制</p>
<ol>
<li>默认的继承访问权限。struct 是 public 的，class 是 private 的。</li>
<li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li>
</ol>
<p><strong>union 联合</strong><br>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：1. 默认访问控制符为 public</p>
<ol start="2">
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的。</li>
</ol>
<p><strong>union 使用：</strong></p>
<p>#include<iostream><br>union UnionTest {<br>    UnionTest() : i(10) {};<br>    int i;<br>    double d;<br>};<br>static union {<br>    int i;<br>    double d;<br>};<br>int main() {<br>    UnionTest u;<br>    union {<br>        int i;<br>        double d;<br>    };<br>    std::cout &lt;&lt; u.i &lt;&lt; std::endl;  // 输出 UnionTest 联合的 10<br>    ::i = 20;<br>    std::cout &lt;&lt; ::i &lt;&lt; std::endl;  // 输出全局静态匿名联合的 20<br>    i = 30;<br>    std::cout &lt;&lt; i &lt;&lt; std::endl;    // 输出局部匿名联合的 30<br>    return 0;<br>}</iostream></p>
<p><strong>explicit（显式）关键字：</strong></p>
<ol>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但?按语境转换?除外</li>
</ol>
<p><strong>explicit 使用：</strong><br>struct A<br>{<br>        A(int) { }<br>        operator bool() const { return true; }<br>};</p>
<p>struct B<br>{<br>        explicit B(int) {}<br>        explicit operator bool() const { return true; }<br>};</p>
<p>void doA(A a) {}</p>
<p>void doB(B b) {}</p>
<p>int main()<br>{<br>        A a1(1);         // OK：直接初始化<br>        A a2 = 1;            // OK：复制初始化<br>        A a3{ 1 };           // OK：直接列表初始化<br>        A a4 = { 1 };                // OK：复制列表初始化<br>        A a5 = (A)1;         // OK：允许 static_cast 的显式转换<br>        doA(1);                   // OK：允许从 int 到 A 的隐式转换<br>        if (a1);             // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换<br>        bool a6（a1）;         // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换<br>        bool a7 = a1;                // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换<br>        bool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化<br>        B b1(1);         // OK：直接初始化<br>        B b2 = 1;            // 错误：被 explicit 修饰构造函数的对象不可以复制初始化<br>        B b3{ 1 };           // OK：直接列表初始化<br>        B b4 = { 1 };                // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化<br>        B b5 = (B)1;         // OK：允许 static_cast 的显式转换<br>        doB(1);                   // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换<br>        if (b1);             // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换<br>        bool b6(b1);             // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换<br>        bool b7 = b1;                // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换<br>        bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化<br>        return 0;<br>}</bool></bool></p>
<p><strong>friend 友元类和友元函数：</strong></p>
<ol>
<li>能访问私有成员</li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ol>
<p><strong>using 声明</strong><br>一条?using 声明?语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：using namespace_name::name;<br>构造函数的 using 声明在 C++11 中，派生类能够重用其直接基类定义的构造函数。<br>class Derived : Base {<br>public:<br>    using Base::Base;<br>    /<em> … </em>/<br>};<br>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：<br>derived(parms) : base(args) { }</p>
<p>using 指示<br>using 指示?使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：<br>using namespace_name name;</p>
<p><strong>尽量少使用?using 指示?污染命名空间</strong><br>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p>
<p><strong>using 使用：</strong><br>尽量少使用?using 指示using namespace std;<br>应该多使用?using 声明int x;<br>std::cin &gt;&gt; x ;<br>std::cout &lt;&lt; x &lt;&lt; std::endl;<br>或者using std::cin;<br>using std::cout;<br>using std::endl;<br>int x;<br>cin &gt;&gt; x;<br>cout &lt;&lt; x &lt;&lt; endl;</p>
<p><strong>:: 范围解析运算符：</strong><br><strong>分类：</strong></p>
<ol>
<li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ol>
<p><strong>:: 使用:</strong><br>int count = 0;        // 全局（::）的 count<br>class A {<br>public:<br>    static int count; // 类 A 的 count（A::count）<br>};</p>
<p>int main() {<br>    ::count = 1;      // 设置全局的 count 的值为 1<br>    A::count = 2;     // 设置类 A 的 count 为 2<br>    int count = 0;    // 局部的 count<br>    count = 3;        // 设置局部的 count 的值为 3<br>    return 0;<br>}</p>
<p><strong>enum 枚举类型:</strong><br>限定作用域的枚举类型<br>enum class open_modes { input, output, append };<br>不限定作用域的枚举类型<br>enum color { red, yellow, green };<br>enum { floatPrec = 6, doublePrec = 10 };</p>
<p><strong>decltype:</strong><br>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：<br>decltype ( expression )<br>// 尾置返回允许我们在参数列表之后声明返回类型template <typename it><br>auto fcn(It beg, It end) -&gt; decltype(<em>beg)<br>{<br>    // 处理序列<br>    return </em>beg;    // 返回序列中一个元素的引用<br>}<br>// 为了使用模板参数成员，必须用 typenametemplate <typename it><br>auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(<em>beg)&gt;::type<br>{<br>    // 处理序列<br>    return </em>beg;    // 返回序列中一个元素的拷贝<br>}</typename></typename></p>
<p><strong>引用:</strong><br>左值引用<br>常规引用，一般表示对象的身份。右值引用右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。<br>右值引用<br>可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：<br>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。<br>能够更简洁明确地定义泛型函数。<br>引用折叠X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp;?可折叠成?X&amp;X&amp;&amp; &amp;&amp;?可折叠成?X&amp;&amp;</p>
<p><strong>宏:</strong><br>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</p>
<p><strong>成员初始化列表:</strong><br>好处<br>更高效：少了一次调用默认构造函数的过程。有些场合必须要用初始化列表：</p>
<ol>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。</li>
</ol>
<p><strong>initializer_list 列表初始化:</strong><br>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个?std::initializer_list?参数.</p>
<p>#include <iostream></iostream></p>
<p>#include <vector></vector></p>
<p>#include &lt;initializer_list&gt;</p>
<p>template <class t><br>struct S {<br>    std::vector<t> v;<br>    S(std::initializer_list<t> l) : v(l) {<br>         std::cout &lt;&lt; “constructed with a “ &lt;&lt; l.size() &lt;&lt; “-element list\n”;<br>    }<br>    void append(std::initializer_list<t> l) {<br>        v.insert(v.end(), l.begin(), l.end());<br>    }<br>    std::pair<const t*, std::size_t> c_arr() const {<br>        return {&amp;v[0], v.size()};  // 在 return 语句中复制列表初始化<br>                                   // 这不使用 std::initializer_list<br>    }<br>};</const></t></t></t></class></p>
<p>template <typename t><br>void templated_fn(T) {}</typename></p>
<p>int main()<br>{<br>    S<int> s = {1, 2, 3, 4, 5}; // 复制初始化<br>    s.append({6, 7, 8});      // 函数调用中的列表初始化<br>    std::cout &lt;&lt; “The vector size is now “ &lt;&lt; s.c_arr().second &lt;&lt; “ ints:\n”;<br>    for (auto n : s.v)<br>        std::cout &lt;&lt; n &lt;&lt; ‘ ‘;<br>    std::cout &lt;&lt; ‘\n’;<br>    std::cout &lt;&lt; “Range-for over brace-init-list: \n”;<br>    for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作<br>        std::cout &lt;&lt; x &lt;&lt; ‘ ‘;<br>    std::cout &lt;&lt; ‘\n’;<br>    auto al = {10, 11, 12};   // auto 的特殊规则<br>    std::cout &lt;&lt; “The list bound to auto has size() = “ &lt;&lt; al.size() &lt;&lt; ‘\n’;<br>//    templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，<br>                             // 它无类型，故 T 无法推导<br>    templated_fn&lt;std::initializer_list<int>&gt;({1, 2, 3}); // OK<br>    templated_fn&lt;std::vector<int>&gt;({1, 2, 3});           // 也 OK<br>}</int></int></int></p>
<p><strong>面向对象:</strong><br>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。<br><img src="/2019/05/18/c-language-learning/Image.png" alt="面想对象的设计"><br>面向对象三大特征 —— 封装、继承、多态</p>
<p><strong>封装:</strong><br>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p>
<ol>
<li>public?成员：可以被任意实体访问</li>
<li>protected?成员：只允许被子类及本类的成员函数访问</li>
<li>private?成员：只允许被本类的成员函数访问</li>
</ol>
<p><strong>继承:</strong><br>基类（父类）——&gt; 派生类（子类）</p>
<p><strong>多态:</strong></p>
<ol>
<li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。2. 多态是以封装和继承为基础的。<br>C++ 多态分类及实现：<br>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载<br>子类型多态（Subtype Polymorphism，运行期）：虚函数<br>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板<br>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
<p><strong>静态多态（编译期/早绑定）:</strong><br>函数重载<br>class A<br>{<br>public:<br>    void do(int a);<br>    void do(int a, int b);<br>};</p>
<p><strong>动态多态（运行期期/晚绑定）:</strong><br> 虚函数：用 virtual 修饰成员函数，使其成为虚函数<br>注意：</p>
<ol>
<li>普通函数（非类成员函数）不能是虚函数</li>
<li>静态函数（static）不能是虚函数</li>
<li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li>
<li>内联函数不能是表现多态性时的虚函数，解释见：虚函数（virtual）可以是内联函数（inline）吗？<br><strong>动态多态使用:</strong></li>
</ol>
<p>class Shape                     // 形状类<br>{<br>public:<br>    virtual double calcArea()<br>    {<br>        …<br>    }<br>    virtual ~Shape();<br>};<br>class Circle : public Shape     // 圆形类<br>{<br>public:<br>    virtual double calcArea();<br>    …<br>};<br>class Rect : public Shape       // 矩形类<br>{<br>public:<br>    virtual double calcArea();<br>    …<br>};<br>int main()<br>{<br>    Shape <em> shape1 = new Circle(4.0);<br>    Shape </em> shape2 = new Rect(5.0, 6.0);<br>    shape1-&gt;calcArea();         // 调用圆形类里面的方法<br>    shape2-&gt;calcArea();         // 调用矩形类里面的方法<br>    delete shape1;<br>    shape1 = nullptr;<br>    delete shape2;<br>    shape2 = nullptr;<br>    return 0;<br>}</p>
<p><strong>虚析构函数:</strong><br>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。<br>class Shape<br>{<br>public:<br>    Shape();                    // 构造函数不能是虚函数<br>    virtual double calcArea();<br>    virtual ~Shape();           // 虚析构函数<br>};<br>class Circle : public Shape     // 圆形类<br>{<br>public:<br>    virtual double calcArea();<br>    …<br>};<br>int main()<br>{<br>    Shape * shape1 = new Circle(4.0);<br>    shape1-&gt;calcArea();<br>    delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。<br>    shape1 = NULL;<br>    return 0；<br>}</p>
<p><strong>纯虚函数:</strong><br>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。<br>virtual int A() = 0;</p>
<p><strong>虚函数、纯虚函数:</strong></p>
<ol>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li>
<li>虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。 当然大家也可以完成自己的实现。</li>
<li>纯虚函数关注的是接口的统一性，实现由子类完成。带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。</li>
</ol>
<p><strong>虚函数指针、虚函数表:</strong></p>
<ol>
<li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li>
<li>虚函数表：在程序只读数据段（.rodata section，见：目标文件存储结构），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li>
</ol>
<p><strong>虚继承:</strong></p>
<ol>
<li>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</li>
<li>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</li>
<li>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</li>
</ol>
<p><strong>虚继承、虚函数:</strong><br>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）<br>不同之处：<br>虚继承</p>
<ol>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移虚函数<br>虚函数</li>
<li>不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ol>
<p><strong>模板类、成员模板、虚函数:</strong></p>
<ol>
<li>模板类中可以使用虚函数</li>
<li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li>
</ol>
<p><strong>抽象类、接口类、聚合类:</strong><br>抽象类：含有纯虚函数的类<br>接口类：仅含有纯虚函数的抽象类<br>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<br>所有成员都是 public<br>没有定义任何构造函数<br>没有类内初始化<br>没有基类，也没有 virtual 函数</p>
<p><strong>内存分配和管理:</strong><br>malloc、calloc、realloc、alloca</p>
<ol>
<li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li>
<li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li>
<li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li>
<li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li>
</ol>
<p><strong>malloc、free:</strong><br>用于分配、释放内存<br>malloc、free 使用申请内存，确认是否申请成功<br>char <em>str = (char</em>) malloc(100);<br>assert(str != nullptr);<br>释放内存后指针置空<br>free(p);<br>p = nullptr;</p>
<p><strong>new、delete:</strong></p>
<ol>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
</ol>
<p>int main()<br>{<br>    T* t = new T();     // 先内存分配 ，再构造函数<br>    delete t;           // 先析构函数，再内存释放<br>    return 0;<br>}</p>
<p><strong>定位 new:</strong><br>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。<br>new (place_address) type<br>new (place_address) type (initializers)<br>new (place_address) type [size]<br>new (place_address) type [size] { braced initializer list }<br>place_address?是个指针<br>initializers?提供一个（可能为空的）以逗号分隔的初始值列表</p>
<p><strong>如何定义一个只能在堆上（栈上）生成对象的类？</strong><br><strong>只能在堆上</strong><br>方法：将析构函数设置为私有<br>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。<br><strong>只能在栈上</strong><br>方法：将 new 和 delete 重载为私有原<br>因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>
<p><strong>智能指针</strong><br>C++ 标准库（STL）中<br>头文件：#include <memory><br>C++ 98<br>std::auto_ptr<a href="std::string" target="_blank" rel="noopener">std::string</a> ps (new std::string(str))；<br>C++ 11<br>shared_ptr<br>unique_ptr<br>weak_ptr<br>auto_ptr（被 C++11 弃用）</memory></p>
<p>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。<br>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</p>
<p><strong>shared_ptr</strong><br>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁<strong>weak_ptr</strong><br>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题<br><strong>unique_ptr</strong><br>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。unique_ptr 用于取代<br><strong>auto_ptr</strong><br>auto_ptr被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的?std::move?语义，以及其他瑕疵。</p>
<p><strong>强制类型转换运算符:</strong><br><strong>static_cast</strong></p>
<ol>
<li>用于非多态类型的转换</li>
<li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li>
<li>通常用于转换数值数据类型（如 float -&gt; int）</li>
<li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li>
<li>向上转换是一种隐式转换。</li>
</ol>
<p><strong>dynamic_cast</strong></p>
<ol>
<li>用于多态类型的转换</li>
<li>执行行运行时类型检查</li>
<li>只适用于指针或引用对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li>
<li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li>
</ol>
<p><strong>const_cast</strong><br>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</p>
<p><strong>reinterpret_cast</strong></p>
<ol>
<li>用于位的简单重新解释</li>
<li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li>
<li>允许将任何指针转换为任何其他指针类型（如?char<em>?到?int</em>?或?One_class<em>?到?Unrelated_class</em>?之类的转换，但其本身并不安全）</li>
<li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li>
<li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。</li>
<li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li>
</ol>
<p><strong>运行时类型信息 (RTTI)</strong><br><strong>dynamic_cast</strong><br>用于多态类型的转换<br><strong>typeid</strong></p>
<ol>
<li>typeid 运算符允许在运行时确定对象的类型</li>
<li>type_id 返回一个 type_info 对象的引用</li>
<li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li>
<li>只能获取对象的实际类型<br><strong>type_info</strong></li>
<li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li>
<li>头文件：typeinfo<br><strong>typeid、type_info 使用</strong></li>
</ol>
<p>class Flyable                       // 能飞的<br>{<br>public:<br>    virtual void takeoff() = 0;     // 起飞<br>    virtual void land() = 0;        // 降落<br>};<br>class Bird : public Flyable         // 鸟<br>{<br>public:<br>    void foraging() {…}           // 觅食<br>    virtual void takeoff() {…}<br>    virtual void land() {…}<br>};<br>class Plane : public Flyable        // 飞机<br>{<br>public:<br>    void carry() {…}              // 运输<br>    virtual void take off() {…}<br>    virtual void land() {…}<br>};</p>
<p>class type_info<br>{<br>public:<br>    const char* name() const;<br>    bool operator == (const type_info &amp; rhs) const;<br>    bool operator != (const type_info &amp; rhs) const;<br>    int before(const type_info &amp; rhs) const;<br>    virtual ~type_info();<br>private:<br>    …<br>};</p>
<p>class doSomething(Flyable <em>obj)                 // 做些事情<br>{<br>    obj-&gt;takeoff();<br>    cout &lt;&lt; typeid(</em>obj).name() &lt;&lt; endl;        // 输出传入对象类型（”class Bird” or “class Plane”）<br>    if(typeid(<em>obj) == typeid(Bird))            // 判断对象类型<br>    {<br>        Bird </em>bird = dynamic_cast<bird *>(obj); // 对象转化<br>        bird-&gt;foraging();<br>    }<br>    obj-&gt;land();<br>};</bird></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/yu.jpg" alt="决斗者">
            
              <p class="site-author-name" itemprop="name">决斗者</p>
              <div class="site-description motion-element" itemprop="description">记录学习的点滴，每天一小步</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">决斗者</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.1</div>




        






  <div style="display: none;">
   <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277620454'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1277620454%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
    </div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  


</body>
</html>
