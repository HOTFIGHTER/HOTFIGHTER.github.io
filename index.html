<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/pokeball_menu.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/pokeball_menu.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录学习的点滴，每天一小步">
<meta name="keywords" content="Java、C++、Python、TensorFlow、Android">
<meta property="og:type" content="website">
<meta property="og:title" content="决斗者的学习博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="决斗者的学习博客">
<meta property="og:description" content="记录学习的点滴，每天一小步">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="决斗者的学习博客">
<meta name="twitter:description" content="记录学习的点滴，每天一小步">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>决斗者的学习博客</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6697a1363f65085bd28b3b4b490bdd74";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">决斗者的学习博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/19/bazel-start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="决斗者">
      <meta itemprop="description" content="记录学习的点滴，每天一小步">
      <meta itemprop="image" content="/images/yu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="决斗者的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/19/bazel-start/" class="post-title-link" itemprop="url">Bazel入门学习</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-19 07:56:35 / 修改时间：08:31:18" itemprop="dateCreated datePublished" datetime="2019-06-19T07:56:35+08:00">2019-06-19</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Bazel入门学习"><a href="#Bazel入门学习" class="headerlink" title="Bazel入门学习"></a>Bazel入门学习</h4><p>1 Bazel简介：<br>bazel是Google开源的一套编译构建工具，广泛应用于Google内部，包括TensorFlow项目。修改TensorFlow内部源码，需要使用bazel来编译，<br>故有必要了解下bazel。bazel优点很多，主要有<br>1 构建快。支持增量编译。对依赖关系进行了优化，从而支持并发执行。<br>2 可构建多种语言。bazel可用来构建Java C++ Android ios等很多语言和框架，并支持mac windows linux等不同平台<br>3 可伸缩。可处理任意大小的代码库，可处理多个库，也可以处理单个库<br>4 可扩展。使用bazel扩展语言可支持新语言和新平台。</p>
<p>2 Bazel项目结构：<br>和Makefile一样，使用bazel编译也必须满足它的项目结构要求。bazel顶层，也就是根目录下为工作区workspace，workspace下包含多个package，<br>每个package又包含多个编译目标target。<br>2.1 工作区workspace:<br>要进行构建的文件系统，根目录下必须包含一个文件名为WORKSPACE的文件，即使它内容为空。它指明了构建的根目录。文件系统中包括源文件，<br>头文件，输出目录的符号链接等。下面是TensorFlow源码根目录下的WORKSPACE<br>workspace(name = “org_tensorflow”)<br>http_archive(<br>    name = “io_bazel_rules_closure”,<br>    sha256 = “110fe68753413777944b473c25eed6368c4a0487cee23a7bac1b13cc49d3e257”,<br>    strip_prefix = “rules_closure-4af89ef1db659eb41f110df189b67d4cf14073e1”,<br>    urls = [<br>        “<a href="https://mirror.bazel.build/github.com/bazelbuild/rules_closure/archive/4af89ef1db659eb41f110df189b67d4cf14073e1.tar.gz&quot;" target="_blank" rel="noopener">https://mirror.bazel.build/github.com/bazelbuild/rules_closure/archive/4af89ef1db659eb41f110df189b67d4cf14073e1.tar.gz&quot;</a>,<br>        “<a href="https://github.com/bazelbuild/rules_closure/archive/4af89ef1db659eb41f110df189b67d4cf14073e1.tar.gz&quot;" target="_blank" rel="noopener">https://github.com/bazelbuild/rules_closure/archive/4af89ef1db659eb41f110df189b67d4cf14073e1.tar.gz&quot;</a>,  # 2017-08-28<br>    ],<br>)<br>load(“@io_bazel_rules_closure//closure:defs.bzl”, “closure_repositories”)<br>closure_repositories()<br>load(“//tensorflow:workspace.bzl”, “tf_workspace”)</p>
<h1 id="Uncomment-and-update-the-paths-in-these-entries-to-build-the-Android-demo"><a href="#Uncomment-and-update-the-paths-in-these-entries-to-build-the-Android-demo" class="headerlink" title="Uncomment and update the paths in these entries to build the Android demo."></a>Uncomment and update the paths in these entries to build the Android demo.</h1><p>#android_sdk_repository(</p>
<h1 id="name-“androidsdk”"><a href="#name-“androidsdk”" class="headerlink" title="name = “androidsdk”,"></a>name = “androidsdk”,</h1><h1 id="api-level-23"><a href="#api-level-23" class="headerlink" title="api_level = 23,"></a>api_level = 23,</h1><h1 id="Ensure-that-you-have-the-build-tools-version-below-installed-in-the"><a href="#Ensure-that-you-have-the-build-tools-version-below-installed-in-the" class="headerlink" title="# Ensure that you have the build_tools_version below installed in the"></a># Ensure that you have the build_tools_version below installed in the</h1><h1 id="SDK-manager-as-it-updates-periodically"><a href="#SDK-manager-as-it-updates-periodically" class="headerlink" title="# SDK manager as it updates periodically."></a># SDK manager as it updates periodically.</h1><h1 id="build-tools-version-“26-0-1”"><a href="#build-tools-version-“26-0-1”" class="headerlink" title="build_tools_version = “26.0.1”,"></a>build_tools_version = “26.0.1”,</h1><h1 id="Replace-with-path-to-Android-SDK-on-your-system"><a href="#Replace-with-path-to-Android-SDK-on-your-system" class="headerlink" title="# Replace with path to Android SDK on your system"></a># Replace with path to Android SDK on your system</h1><h1 id="path-“-lt-PATH-TO-SDK-gt-”"><a href="#path-“-lt-PATH-TO-SDK-gt-”" class="headerlink" title="path = “&lt;PATH_TO_SDK&gt;”,"></a>path = “&lt;PATH_TO_SDK&gt;”,</h1><p>#)<br>#</p>
<p>#android_ndk_repository(</p>
<h1 id="name-”androidndk”"><a href="#name-”androidndk”" class="headerlink" title="name=”androidndk”,"></a>name=”androidndk”,</h1><h1 id="path-”-lt-PATH-TO-NDK-gt-”"><a href="#path-”-lt-PATH-TO-NDK-gt-”" class="headerlink" title="path=”&lt;PATH_TO_NDK&gt;”,"></a>path=”&lt;PATH_TO_NDK&gt;”,</h1><h1 id="This-needs-to-be-14-or-higher-to-compile-TensorFlow"><a href="#This-needs-to-be-14-or-higher-to-compile-TensorFlow" class="headerlink" title="# This needs to be 14 or higher to compile TensorFlow."></a># This needs to be 14 or higher to compile TensorFlow.</h1><h1 id="Please-specify-API-level-to-gt-21-to-build-for-64-bit"><a href="#Please-specify-API-level-to-gt-21-to-build-for-64-bit" class="headerlink" title="# Please specify API level to &gt;= 21 to build for 64-bit"></a># Please specify API level to &gt;= 21 to build for 64-bit</h1><h1 id="archtectures-or-the-Android-NDK-will-automatically-select-biggest"><a href="#archtectures-or-the-Android-NDK-will-automatically-select-biggest" class="headerlink" title="# archtectures or the Android NDK will automatically select biggest"></a># archtectures or the Android NDK will automatically select biggest</h1><h1 id="API-level-that-it-supports-without-notice"><a href="#API-level-that-it-supports-without-notice" class="headerlink" title="# API level that it supports without notice."></a># API level that it supports without notice.</h1><h1 id="Note-that-the-NDK-version-is-not-the-API-level"><a href="#Note-that-the-NDK-version-is-not-the-API-level" class="headerlink" title="# Note that the NDK version is not the API level."></a># Note that the NDK version is not the API level.</h1><h1 id="api-level-14"><a href="#api-level-14" class="headerlink" title="api_level=14)"></a>api_level=14)</h1><h1 id="Please-add-all-new-TensorFlow-dependencies-in-workspace-bzl"><a href="#Please-add-all-new-TensorFlow-dependencies-in-workspace-bzl" class="headerlink" title="Please add all new TensorFlow dependencies in workspace.bzl."></a>Please add all new TensorFlow dependencies in workspace.bzl.</h1><p>tf_workspace()</p>
<p>new_http_archive(<br>    name = “inception5h”,<br>    build_file = “models.BUILD”,<br>    sha256 = “d13569f6a98159de37e92e9c8ec4dae8f674fbf475f69fe6199b514f756d4364”,<br>    urls = [<br>        “<a href="http://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip&quot;" target="_blank" rel="noopener">http://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip&quot;</a>,<br>        “<a href="http://download.tensorflow.org/models/inception5h.zip&quot;" target="_blank" rel="noopener">http://download.tensorflow.org/models/inception5h.zip&quot;</a>,<br>    ],<br>)</p>
<p>new_http_archive(<br>    name = “mobile_ssd”,<br>    build_file = “models.BUILD”,<br>    sha256 = “bddd81ea5c80a97adfac1c9f770e6f55cbafd7cce4d3bbe15fbeb041e6b8f3e8”,<br>    urls = [<br>        “<a href="http://storage.googleapis.com/download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_android_export.zip&quot;" target="_blank" rel="noopener">http://storage.googleapis.com/download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_android_export.zip&quot;</a>,<br>        “<a href="http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_android_export.zip&quot;" target="_blank" rel="noopener">http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_android_export.zip&quot;</a>,<br>    ],<br>)</p>
<p>new_http_archive(<br>    name = “mobile_multibox”,<br>    build_file = “models.BUILD”,<br>    sha256 = “859edcddf84dddb974c36c36cfc1f74555148e9c9213dedacf1d6b613ad52b96”,<br>    urls = [<br>        “<a href="http://storage.googleapis.com/download.tensorflow.org/models/mobile_multibox_v1a.zip&quot;" target="_blank" rel="noopener">http://storage.googleapis.com/download.tensorflow.org/models/mobile_multibox_v1a.zip&quot;</a>,<br>        “<a href="http://download.tensorflow.org/models/mobile_multibox_v1a.zip&quot;" target="_blank" rel="noopener">http://download.tensorflow.org/models/mobile_multibox_v1a.zip&quot;</a>,<br>    ],<br>)</p>
<p>new_http_archive(<br>    name = “stylize”,<br>    build_file = “models.BUILD”,<br>    sha256 = “3d374a730aef330424a356a8d4f04d8a54277c425e274ecb7d9c83aa912c6bfa”,<br>    urls = [<br>        “<a href="http://storage.googleapis.com/download.tensorflow.org/models/stylize_v1.zip&quot;" target="_blank" rel="noopener">http://storage.googleapis.com/download.tensorflow.org/models/stylize_v1.zip&quot;</a>,<br>        “<a href="http://download.tensorflow.org/models/stylize_v1.zip&quot;" target="_blank" rel="noopener">http://download.tensorflow.org/models/stylize_v1.zip&quot;</a>,<br>    ],<br>)</p>
<p>new_http_archive(<br>    name = “speech_commands”,<br>    build_file = “models.BUILD”,<br>    sha256 = “c3ec4fea3158eb111f1d932336351edfe8bd515bb6e87aad4f25dbad0a600d0c”,<br>    urls = [<br>        “<a href="http://storage.googleapis.com/download.tensorflow.org/models/speech_commands_v0.01.zip&quot;" target="_blank" rel="noopener">http://storage.googleapis.com/download.tensorflow.org/models/speech_commands_v0.01.zip&quot;</a>,<br>        “<a href="http://download.tensorflow.org/models/speech_commands_v0.01.zip&quot;" target="_blank" rel="noopener">http://download.tensorflow.org/models/speech_commands_v0.01.zip&quot;</a>,<br>    ],<br>)</p>
<p>new_local_repository(<br>    name = “aarch64_compiler”,<br>    path = “/“,<br>    build_file = “aarch64_compiler.BUILD”,<br>)</p>
<p>http_archive：下载bazel文件，然后解压它，这个bazel 目录文件中必须包含BUILD文件。上面的http_archive中指明了要<br>下载io_bazel_rules_closure文件，以及它的下载地址。<br>new_http_archive: 下载文件，然后解压它，然后和其中包含的build_file一起创建bazel目录。<br>load：从.bzl文件中加载一些内容，如上面从defs.bzl文件中加载内容。<br>android_sdk_repository：构建Android app时使用，指定Android sdk目录。<br>android_ndk_repository：构建Android app时使用，指定Android ndk目录。</p>
<p>2.2 包package<br>一个WORKSPACE工作区下可以包括多个包package，每个package可以实现一个子模块，从而让各个模块进行解耦。<br>每个package下必须包含一个BUILD文件，它指定了package的编译构建规则。</p>
<h1 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h1><h1 id="TensorFlow-is-a-computational-framework-primarily-for-use-in-machine"><a href="#TensorFlow-is-a-computational-framework-primarily-for-use-in-machine" class="headerlink" title="TensorFlow is a computational framework, primarily for use in machine"></a>TensorFlow is a computational framework, primarily for use in machine</h1><h1 id="learning-applications"><a href="#learning-applications" class="headerlink" title="learning applications."></a>learning applications.</h1><p>package(<br>    default_visibility = [“//visibility:public”],<br>)<br>licenses([“notice”])  # Apache 2.0<br>load(<br>    “//tensorflow:tensorflow.bzl”,<br>    “tf_cc_test”,<br>    “tf_cc_binary”,<br>    “tf_copts”,<br>    “tf_gen_op_wrappers_cc”,<br>    “cc_library_with_android_deps”,<br>)</p>
<p>cc_library(<br>    name = “gradients”,<br>    srcs = [<br>        “framework/gradients.cc”,<br>        “framework/while_gradients.cc”,<br>        “framework/while_gradients.h”,<br>    ],<br>    hdrs = [“framework/gradients.h”],<br>    deps = [<br>        “:cc_ops”,<br>        “:cc_ops_internal”,<br>        “:grad_op_registry”,<br>        “:ops”,<br>        “:scope”,<br>        “:scope_internal”,<br>        “:while_loop”,<br>        “//tensorflow/core:core_cpu”,<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:lib”,<br>        “//tensorflow/core:lib_internal”,<br>    ],<br>)</p>
<p>tf_cc_test(<br>    name = “framework_gradients_test”,<br>    srcs = [“framework/gradients_test.cc”],<br>    deps = [<br>        “:cc_ops”,<br>        “:client_session”,<br>        “:grad_op_registry”,<br>        “:grad_ops”,<br>        “:gradients”,<br>        “:testutil”,<br>        “//tensorflow/core:all_kernels”,<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:framework_internal”,<br>        “//tensorflow/core:protos_all_cc”,<br>        “//tensorflow/core:test”,<br>        “//tensorflow/core:test_main”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>tf_cc_test(<br>    name = “framework_while_gradients_test”,<br>    size = “small”,<br>    srcs = [“framework/while_gradients_test.cc”],<br>    deps = [<br>        “:cc_ops”,<br>        “:client_session”,<br>        “:grad_op_registry”,<br>        “:grad_ops”,<br>        “:gradients”,<br>        “:testutil”,<br>        “:while_loop”,<br>        “//tensorflow/core:all_kernels”,<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:framework_internal”,<br>        “//tensorflow/core:protos_all_cc”,<br>        “//tensorflow/core:test”,<br>        “//tensorflow/core:test_main”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>cc_library(<br>    name = “gradient_checker”,<br>    srcs = [“framework/gradient_checker.cc”],<br>    hdrs = [“framework/gradient_checker.h”],<br>    deps = [<br>        “:cc_ops”,<br>        “:client_session”,<br>        “:gradients”,<br>        “:ops”,<br>        “:scope”,<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:lib”,<br>        “//tensorflow/core:lib_internal”,<br>    ],<br>)</p>
<p>tf_cc_test(<br>    name = “framework_gradient_checker_test”,<br>    srcs = [“framework/gradient_checker_test.cc”],<br>    deps = [<br>        “:cc_ops”,<br>        “:grad_op_registry”,<br>        “:grad_ops”,<br>        “:gradient_checker”,<br>        “:testutil”,<br>        “//tensorflow/core:all_kernels”,<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:framework_internal”,<br>        “//tensorflow/core:test”,<br>        “//tensorflow/core:test_main”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>cc_library(<br>    name = “grad_ops”,<br>    deps = [<br>        “:array_grad”,<br>        “:data_flow_grad”,<br>        “:math_grad”,<br>        “:nn_grad”,<br>    ],<br>)</p>
<p>cc_library(<br>    name = “grad_testutil”,<br>    testonly = 1,<br>    srcs = [“gradients/grad_testutil.cc”],<br>    hdrs = [“gradients/grad_testutil.h”],<br>    deps = [<br>        “:grad_op_registry”,<br>        “:ops”,<br>        “:scope”,<br>    ],<br>)</p>
<p>cc_library_with_android_deps(<br>    name = “ops”,<br>    srcs = [“framework/ops.cc”],<br>    hdrs = [“framework/ops.h”],<br>    android_deps = [“//tensorflow/core:android_tensorflow_lib”],<br>    deps = [<br>        “//tensorflow/core:core_cpu”,<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:lib”,<br>        “//tensorflow/core:lib_internal”,<br>        “//tensorflow/core:protos_all_cc”,<br>    ],<br>)</p>
<p>cc_library_with_android_deps(<br>    name = “scope”,<br>    srcs = [<br>        “framework/scope.cc”,<br>        “framework/scope_internal.h”,<br>    ],<br>    hdrs = [“framework/scope.h”],<br>    android_deps = [“//tensorflow/core:android_tensorflow_lib”],<br>    common_deps = [<br>        “:ops”,<br>    ],<br>    deps = [<br>        “//tensorflow/core:core_cpu”,<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:lib”,<br>        “//tensorflow/core:protos_all_cc”,<br>    ],<br>)</p>
<p>cc_library_with_android_deps(<br>    name = “scope_internal”,<br>    hdrs = [“framework/scope_internal.h”],<br>    common_deps = [<br>        “:scope”,<br>    ],<br>    deps = [],<br>)</p>
<p>tf_cc_test(<br>    name = “framework_scope_test”,<br>    srcs = [“framework/scope_test.cc”],<br>    deps = [<br>        “:ops”,<br>        “:scope”,<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:test”,<br>        “//tensorflow/core:test_main”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>cc_library_with_android_deps(<br>    name = “client_session”,<br>    srcs = [“client/client_session.cc”],<br>    hdrs = [“client/client_session.h”],<br>    android_deps = [“//tensorflow/core:android_tensorflow_lib”],<br>    common_deps = [<br>        “:ops”,<br>        “:scope”,<br>    ],<br>    deps = [<br>        “//tensorflow/core:core_cpu”,<br>        “//tensorflow/core:lib”,<br>        “//tensorflow/core:protos_all_cc”,<br>    ],<br>)</p>
<p>tf_cc_test(<br>    name = “client_client_session_test”,<br>    srcs = [“client/client_session_test.cc”],<br>    deps = [<br>        “:cc_ops”,<br>        “:client_session”,<br>        “//tensorflow/core:all_kernels”,<br>        “//tensorflow/core:core_cpu_internal”,<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:lib”,<br>        “//tensorflow/core:tensorflow”,<br>        “//tensorflow/core:test”,<br>        “//tensorflow/core:test_main”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>cc_library_with_android_deps(<br>    name = “const_op”,<br>    srcs = [“ops/const_op.cc”],<br>    hdrs = [“ops/const_op.h”],<br>    android_deps = [<br>        “//tensorflow/core:android_tensorflow_lib”,<br>    ],<br>    common_deps = [<br>        “:ops”,<br>        “:scope”,<br>    ],<br>    deps = [<br>        “//tensorflow/core:core_cpu”,<br>        “//tensorflow/core:framework”,<br>    ],<br>)</p>
<p>tf_cc_test(<br>    name = “ops_const_op_test”,<br>    srcs = [“ops/const_op_test.cc”],<br>    deps = [<br>        “:const_op”,<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:test”,<br>        “//tensorflow/core:test_main”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>cc_library_with_android_deps(<br>    name = “while_loop”,<br>    srcs = [“ops/while_loop.cc”],<br>    hdrs = [“ops/while_loop.h”],<br>    android_deps = [<br>        “//tensorflow/core:android_tensorflow_lib”,<br>    ],<br>    common_deps = [<br>        “:cc_ops”,<br>        “:cc_ops_internal”,<br>        “:ops”,<br>        “:scope”,<br>        “:scope_internal”,<br>    ],<br>    deps = [<br>        “//tensorflow/core:core_cpu”,<br>        “//tensorflow/core:framework”,<br>    ],<br>)</p>
<p>tf_cc_test(<br>    name = “ops_while_loop_test”,<br>    size = “small”,<br>    srcs = [“ops/while_loop_test.cc”],<br>    deps = [<br>        “:cc_ops”,<br>        “:client_session”,<br>        “:testutil”,<br>        “:while_loop”,<br>        “//tensorflow/core:core_cpu”,<br>        “//tensorflow/core:test”,<br>        “//tensorflow/core:test_main”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>cc_library(<br>    name = “grad_op_registry”,<br>    srcs = [“framework/grad_op_registry.cc”],<br>    hdrs = [“framework/grad_op_registry.h”],<br>    deps = [<br>        “:ops”,<br>        “:scope”,<br>    ],<br>)</p>
<p>cc_library(<br>    name = “array_grad”,<br>    srcs = [“gradients/array_grad.cc”],<br>    deps = [<br>        “:cc_ops”,<br>        “:cc_ops_internal”,<br>        “:grad_op_registry”,<br>        “:gradients”,<br>        “//tensorflow/core:lib_proto_parsing”,<br>    ],<br>    alwayslink = 1,<br>)</p>
<p>tf_cc_test(<br>    name = “gradients_array_grad_test”,<br>    srcs = [“gradients/array_grad_test.cc”],<br>    deps = [<br>        “:array_grad”,<br>        “:cc_ops”,<br>        “:cc_ops_internal”,<br>        “:grad_op_registry”,<br>        “:grad_testutil”,<br>        “:gradient_checker”,<br>        “:testutil”,<br>        “//tensorflow/core:test”,<br>        “//tensorflow/core:test_main”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>cc_library(<br>    name = “math_grad”,<br>    srcs = [“gradients/math_grad.cc”],<br>    deps = [<br>        “:cc_ops”,<br>        “:cc_ops_internal”,<br>        “:grad_op_registry”,<br>        “:gradients”,<br>    ],<br>    alwayslink = 1,<br>)</p>
<p>tf_cc_test(<br>    name = “gradients_math_grad_test”,<br>    srcs = [“gradients/math_grad_test.cc”],<br>    deps = [<br>        “:cc_ops”,<br>        “:grad_op_registry”,<br>        “:grad_testutil”,<br>        “:gradient_checker”,<br>        “:math_grad”,<br>        “:testutil”,<br>        “//tensorflow/core:lib_internal”,<br>        “//tensorflow/core:test”,<br>        “//tensorflow/core:test_main”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>cc_library(<br>    name = “nn_grad”,<br>    srcs = [“gradients/nn_grad.cc”],<br>    deps = [<br>        “:cc_ops”,<br>        “:cc_ops_internal”,<br>        “:grad_op_registry”,<br>        “:gradients”,<br>    ],<br>    alwayslink = 1,<br>)</p>
<p>tf_cc_test(<br>    name = “gradients_nn_grad_test”,<br>    srcs = [“gradients/nn_grad_test.cc”],<br>    deps = [<br>        “:cc_ops”,<br>        “:grad_op_registry”,<br>        “:grad_testutil”,<br>        “:gradient_checker”,<br>        “:nn_grad”,<br>        “:testutil”,<br>        “//tensorflow/core:lib_internal”,<br>        “//tensorflow/core:test”,<br>        “//tensorflow/core:test_main”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>cc_library(<br>    name = “data_flow_grad”,<br>    srcs = [“gradients/data_flow_grad.cc”],<br>    deps = [<br>        “:cc_ops”,<br>        “:cc_ops_internal”,<br>        “:grad_op_registry”,<br>        “:gradients”,<br>    ],<br>    alwayslink = 1,<br>)</p>
<p>tf_cc_test(<br>    name = “gradients_data_flow_grad_test”,<br>    size = “small”,<br>    srcs = [“gradients/data_flow_grad_test.cc”],<br>    deps = [<br>        “:cc_ops”,<br>        “:data_flow_grad”,<br>        “:grad_op_registry”,<br>        “:grad_testutil”,<br>        “:gradient_checker”,<br>        “:testutil”,<br>        “//tensorflow/core:lib_internal”,<br>        “//tensorflow/core:test”,<br>        “//tensorflow/core:test_main”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>tf_gen_op_wrappers_cc(<br>    name = “cc_ops”,<br>    op_lib_names = [<br>        “array_ops”,<br>        “audio_ops”,<br>        “candidate_sampling_ops”,<br>        “control_flow_ops”,<br>        “data_flow_ops”,<br>        “image_ops”,<br>        “io_ops”,<br>        “linalg_ops”,<br>        “logging_ops”,<br>        “lookup_ops”,<br>        “math_ops”,<br>        “nn_ops”,<br>        “no_op”,<br>        “parsing_ops”,<br>        “random_ops”,<br>        “sparse_ops”,<br>        “state_ops”,<br>        “string_ops”,<br>        “training_ops”,<br>        “user_ops”,<br>    ],</p>
<pre><code>other_hdrs = [
    &quot;ops/const_op.h&quot;,
    &quot;ops/standard_ops.h&quot;,
],

override_file = &quot;ops/op_gen_overrides.pbtxt&quot;,
pkg = &quot;//tensorflow/core&quot;,
</code></pre><p>)</p>
<p>tf_cc_test(<br>    name = “framework_cc_ops_test”,<br>    srcs = [“framework/cc_ops_test.cc”],<br>    deps = [<br>        “:cc_ops”,<br>        “:client_session”,<br>        “:test_op”,<br>        “:test_op_op_lib”,<br>        “:testutil”,<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:test”,<br>        “//tensorflow/core:test_main”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>tf_gen_op_wrappers_cc(<br>    name = “sendrecv_ops”,<br>    include_internal_ops = 1,<br>    op_lib_names = [<br>        “sendrecv_ops”,<br>    ],</p>
<pre><code>pkg = &quot;//tensorflow/core&quot;,
</code></pre><p>)</p>
<p>tf_gen_op_wrappers_cc(<br>    name = “function_ops”,<br>    include_internal_ops = 1,<br>    op_lib_names = [<br>        “function_ops”,<br>    ],<br>    pkg = “//tensorflow/core”,<br>    visibility = [“//tensorflow:internal”],<br>)</p>
<p>tf_gen_op_wrappers_cc(<br>    name = “functional_ops”,<br>    include_internal_ops = 1,<br>    op_lib_names = [<br>        “functional_ops”,<br>    ],<br>    pkg = “//tensorflow/core”,<br>    visibility = [“//tensorflow:internal”],<br>)</p>
<p>tf_gen_op_wrappers_cc(<br>    name = “resource_variable_ops”,<br>    include_internal_ops = 1,<br>    op_lib_names = [<br>        “resource_variable_ops”,<br>    ],<br>    pkg = “//tensorflow/core”,<br>    visibility = [“//tensorflow:internal”],<br>)</p>
<p>tf_gen_op_wrappers_cc(<br>    name = “remote_fused_graph_ops”,<br>    op_lib_names = [<br>        “remote_fused_graph_ops”,<br>    ],<br>    pkg = “//tensorflow/core”,<br>)</p>
<p>cc_library_with_android_deps(<br>    name = “cc_op_gen_main”,<br>    srcs = [<br>        “framework/cc_op_gen.cc”,<br>        “framework/cc_op_gen.h”,<br>        “framework/cc_op_gen_main.cc”,<br>    ],<br>    android_deps = [<br>        “//tensorflow/core:android_tensorflow_lib”,<br>    ],<br>    copts = tf_copts(),<br>    deps = [<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:lib”,<br>        “//tensorflow/core:lib_internal”,<br>        “//tensorflow/core:op_gen_lib”,<br>        “//tensorflow/core:op_gen_overrides_proto_cc”,<br>        “//tensorflow/core:proto_text”,<br>        “//tensorflow/core:protos_all_cc”,<br>    ],<br>)</p>
<p>cc_library(<br>    name = “test_op_op_lib”,<br>    srcs = [“framework/test_op.cc”],<br>    linkstatic = 1,<br>    deps = [“//tensorflow/core:framework”],<br>    alwayslink = 1,<br>)</p>
<p>cc_library(<br>    name = “testutil”,<br>    testonly = 1,<br>    srcs = [“framework/testutil.cc”],<br>    hdrs = [“framework/testutil.h”],<br>    deps = [<br>        “:client_session”,<br>        “:ops”,<br>        “:scope”,<br>        “//tensorflow/core:core_cpu”,<br>        “//tensorflow/core:lib_internal”,<br>        “//tensorflow/core:tensorflow”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>tf_gen_op_wrappers_cc(<br>    name = “test_op”,<br>    op_lib_names = [<br>        “test_op”,<br>    ],<br>)</p>
<p>tf_cc_binary(<br>    name = “tutorials_example_trainer”,<br>    srcs = [“tutorials/example_trainer.cc”],<br>    copts = tf_copts(),<br>    linkopts = select({<br>        “//tensorflow:windows”: [],<br>        “//tensorflow:windows_msvc”: [],<br>        “//tensorflow:darwin”: [<br>            “-lm”,<br>            “-lpthread”,<br>        ],<br>        “//tensorflow:ios”: [<br>            “-lm”,<br>            “-lpthread”,<br>        ],<br>        “//conditions:default”: [<br>            “-lm”,<br>            “-lpthread”,<br>            “-lrt”,<br>        ],<br>    }),<br>    deps = [<br>        “:cc_ops”,<br>        “//tensorflow/core:core_cpu”,<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:lib”,<br>        “//tensorflow/core:protos_all_cc”,<br>        “//tensorflow/core:tensorflow”,<br>    ],<br>)</p>
<p>filegroup(<br>    name = “all_files”,<br>    srcs = glob(<br>        [“<strong>/*”],<br>        exclude = [<br>            “</strong>/METADATA”,<br>            “**/OWNERS”,<br>        ],<br>    ),<br>    visibility = [“//tensorflow:<strong>subpackages</strong>“],<br>)</p>
<p>cc_library(<br>    name = “queue_runner”,<br>    srcs = [“training/queue_runner.cc”],<br>    hdrs = [“training/queue_runner.h”],<br>    deps = [<br>        “:coordinator”,<br>        “//tensorflow/core:core_cpu”,<br>        “//tensorflow/core:lib”,<br>        “//tensorflow/core:lib_internal”,<br>        “//tensorflow/core:protos_all_cc”,<br>        “//tensorflow/core/kernels:ops_util”,<br>    ],<br>)</p>
<p>tf_cc_test(<br>    name = “queue_runner_test”,<br>    srcs = [“training/queue_runner_test.cc”],<br>    deps = [<br>        “coordinator”,<br>        “:cc_ops”,<br>        “:queue_runner”,<br>        “:scope”,<br>        “//tensorflow/core:core_cpu”,<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:lib”,<br>        “//tensorflow/core:lib_internal”,<br>        “//tensorflow/core:protos_all_cc”,<br>        “//tensorflow/core:tensorflow”,<br>        “//tensorflow/core:test”,<br>        “//tensorflow/core:test_main”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>cc_library(<br>    name = “coordinator”,<br>    srcs = [“training/coordinator.cc”],<br>    hdrs = [“training/coordinator.h”],<br>    deps = [<br>        “//tensorflow/core:lib”,<br>        “//tensorflow/core:lib_internal”,<br>        “//tensorflow/core:protos_all_cc”,<br>        “//tensorflow/core:tensorflow”,<br>    ],<br>)</p>
<p>tf_cc_test(<br>    name = “coordinator_test”,<br>    srcs = [“training/coordinator_test.cc”],<br>    deps = [<br>        “:cc_ops”,<br>        “:coordinator”,<br>        “:queue_runner”,<br>        “:scope”,<br>        “//tensorflow/core:core_cpu”,<br>        “//tensorflow/core:framework”,<br>        “//tensorflow/core:lib”,<br>        “//tensorflow/core:lib_internal”,<br>        “//tensorflow/core:protos_all_cc”,<br>        “//tensorflow/core:tensorflow”,<br>        “//tensorflow/core:test”,<br>        “//tensorflow/core:test_main”,<br>        “//tensorflow/core:testlib”,<br>    ],<br>)</p>
<p>tf_cc_binary：目标文件编译规则，为一个二进制可执行文件。name必须唯一，srcs指定了源文件，linkopts指定了链接规则，deps指定了依赖文件</p>
<p>cc_library：库文件编译规则，name指定了编译为库文件后的文件名，srcs和hdrs指定源文件和头文件，deps指定需要依赖的其他文件</p>
<p>tf_cc_test：测试文件规则</p>
<p>package：通用方法，定义的值会作用到下面的每个子rule中。default_visibility指定了这个包的默认可见规则。可见的情况下才能被其他package调用。</p>
<p>licenses：通用方法，默认的license</p>
<p>load：通用方法，加载.bzl文件</p>
<p>filegroup：通用方法，为多个编译目标target指定一个名字，glob是一个帮助函数，指定了目录中哪些文件会include，哪些会exclude。visibility<br>指定了target的可见性，也就是可以被哪些package调用</p>
<p>其他一些常用方法可以参看bazel文档 <a href="https://docs.bazel.build/versions/master/be/c-cpp.html#cc_binary.linkopts" target="_blank" rel="noopener">https://docs.bazel.build/versions/master/be/c-cpp.html#cc_binary.linkopts</a></p>
<p>2.2 目标<br>包package是一个容器，组成它的元素称为目标，分为文件和规则。文件分为两种，一种为程序员写的源代码，一种为构建工具生成的文件。<br>规则定义了如何利用输入来构建得到输出，如上面的BUILD。输入一般是源文件，库文件等，输出则一般是生成的构建目标文件。</p>
<p>3 使用Bazel编译项目<br>Bazel提供了一些编译的例子，在<a href="https://github.com/bazelbuild/examples/，可以clone到本地试一下。" target="_blank" rel="noopener">https://github.com/bazelbuild/examples/，可以clone到本地试一下。</a><br>其中examples/cpp-tutorial目录下包含了这么些文件：<br>examples<br>└── cpp-tutorial<br>    ├──stage1<br>    │  └── main<br>    │      ├── BUILD<br>    │      ├── hello-world.cc<br>    │  └── WORKSPACE<br>    ├──stage2<br>    │  ├── main<br>    │  │   ├── BUILD<br>    │  │   ├── hello-world.cc<br>    │  │   ├── hello-greet.cc<br>    │  │   ├── hello-greet.h<br>    │  └── WORKSPACE<br>    └──stage3<br>       ├── main<br>       │   ├── BUILD<br>       │   ├── hello-world.cc<br>       │   ├── hello-greet.cc<br>       │   └── hello-greet.h<br>       ├── lib<br>       │   ├── BUILD<br>       │   ├── hello-time.cc<br>       │   └── hello-time.h<br>       └── WORKSPACE</p>
<p>首先进入到cpp-tutorial/stage1目录下，然后运行以下指令：<br>bazel build //main:hello-world<br>注意target中的//main:是BUILD文件相对于WORKSPACE文件的位置，hello-world则是我们在BUILD文件中命名好的target的名字。<br>这样在bazel-bin文件夹下会产生二进制文件。</p>
<p>4 查看依赖图<br>一个成功的build将所有的依赖都显式定义在了BUILD文件中。Bazel使用这些定义来创建项目的依赖图，这能够加速编译的过程。<br>让我们来可视化一下我们项目的依赖吧。首先，生成依赖图的一段文字描述（即在工作区根目录下运行下述指令）：<br>bazel query –nohost_deps –noimplicit_deps ‘deps(//main:hello-world)’ \ –output graph</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/16/c-standard/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="决斗者">
      <meta itemprop="description" content="记录学习的点滴，每天一小步">
      <meta itemprop="image" content="/images/yu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="决斗者的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/16/c-standard/" class="post-title-link" itemprop="url">C++ primer标准库难点总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-16 21:18:11 / 修改时间：21:20:59" itemprop="dateCreated datePublished" datetime="2019-06-16T21:18:11+08:00">2019-06-16</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="C-primer标准库难点总结（8-12章）"><a href="#C-primer标准库难点总结（8-12章）" class="headerlink" title="C++ primer标准库难点总结（8~12章）"></a>C++ primer标准库难点总结（8~12章）</h4><p>最近在看C++ primer这本书的知识点，这里把8~12章标准库的难点总结了下。<br>1 count&lt;&lt;“hi”&lt;&lt;endl; //输出hi和一个换行，然后刷新缓冲区<br>   Count&lt;&lt;“hi”&lt;&lt;flush; //输出hi,然后刷新缓冲区，不附加任何额外字符<br>   Count&lt;&lt;“hi”&lt;&lt;ends; //输出hi和一个空字符，然后刷新缓冲区</p>
<p>2 顺序容器：<br>   Vector:  可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。<br>   Deque: 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。<br>   List:   双向链表。只支持双向顺序访问。<br>   Forward_list:  单向链表。只支持单向顺序访问。<br>   Array：固定大小数组。支持快速随机访问。不能添加或删除元素。<br>   String: 与vector相似容器，随机访问快。在尾部插入/删除速度快。</p>
<p>3 容器列表初始化：<br>   List<string> authors={“Milton”,”Shakespeare”,”Austen”};<br>   Forward_list<int> ivec(10); //10个元素，每个都初始化为0</int></string></p>
<p>4 int digs[10]={0,1,2,3,4,5,6,7,8,9};<br>   Int cpy[10]=digs;  //错误：内置数组不支持拷贝或赋值<br>   Array&lt;int,10&gt; digits={0,1,2,3,4,5,6,7,8,9};<br>   Array&lt;int,10&gt; copy=digits;  //正确，只要数组类型匹配</p>
<p>5 使用push_back<br>   String word;<br>   While(cin&gt;&gt;word)<br>     Container.push_back(word);</p>
<p>6 使用emplace操作，当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。当我们调用一个emplace成员函数，则是将参数传递给元素类型的构造函数。</p>
<p>7 vector的capacity()代表容量一般大于等于size()</p>
<p>8 vector<int> vec;<br>   fill_n(vec.begin(),vec.size(),0);//将所有元素重置为0</int></p>
<p>9 vector中unique并不是真的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分。</p>
<p>10 lambda表达式：<br>    [capture list] (parameter list) -&gt; return type {function body} 捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字。<br>    &amp;告诉编译器采用捕获引用方式，=则表示采用值捕获方式。</p>
<p>11 可变lambda，对于一个值被拷贝的变量，lambda不会改变其值。如果希望改变一个被捕获的变量的值，就必须在参数列表加上关键字mutable。<br>    Size_t v1=42;<br>    Auto f=<a href>v1</a> mutable{return ++v1;};<br>    V1=0;<br>   Auto j=f();</p>
<p>12  一个map或set中的关键字必须是唯一的，对于一个给定的关键字，只能有一个元素关键字等于它。容器multimap和multiset没有限制，它们都允许多个元素具有相同的关键字。</p>
<p>13 set的迭代器是const的<br>     set<int> iset={0,1,2,3,4,5,6,7,8,9};<br>     Set<int>::iterator set_it= iset.begin();<br>     If(set_it !=iset.end()){<br>       <em>set_it=42;//错误，set中的关键字是只读的<br>       Cout&lt;&lt;</em>set_it&lt;&lt;endl;<br>     }</int></int></p>
<p>14 new在动态内存中为对象分配空间并返回一个指针该对象的指针，我们可以选择对对象进行初始化；delete接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</p>
<p>15 智能指针：<br>     shared_ptr允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，是一种弱引用，指向shared_ptr所管理的对象。<br>     最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准函数。此函数在动态内存中分配一个对象并初始化它。<br>     Shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数会销毁对象，并释放它占用的内存。</p>
<p>16 内存释放：<br>     Int *p(new int(42));<br>     Auto q=p;<br>     Delete p;<br>     p=nullptr;</p>
<p>17 unique_ptr拥有指向的对象，unique_ptr不支持普通的拷贝或赋值操作：<br>     Unique_ptr<string> p1(new string(“ss”));<br>     Unique_ptr<string> p2(p1); //错误：不支持拷贝<br>     Unique_ptr<string> p3;<br>     p3=p2;  //错误:unique_ptr不支持赋值</string></string></string></p>
<p>18 weak_ptr是一个不控制所指向对象生存期的智能指针，它指向一个shared_ptr管理的对象。将weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。<br>    Auto p=make_shared<int>(42);<br>    Weak_ptr<int> wp(p);</int></int></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/15/c-primer-base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="决斗者">
      <meta itemprop="description" content="记录学习的点滴，每天一小步">
      <meta itemprop="image" content="/images/yu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="决斗者的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/15/c-primer-base/" class="post-title-link" itemprop="url">C++ primer基础篇难点总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-15 00:29:23 / 修改时间：00:40:15" itemprop="dateCreated datePublished" datetime="2019-06-15T00:29:23+08:00">2019-06-15</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="C-primer基础篇难点总结（1-7章）"><a href="#C-primer基础篇难点总结（1-7章）" class="headerlink" title="C++ primer基础篇难点总结（1~7章）"></a>C++ primer基础篇难点总结（1~7章）</h4><p>最近在看C++ primer这本书的知识点，这里把1~7章基础篇的难点总结了下。<br>1 变量声明规定了变量的类型和名字；<br>定义与之相比，申请存储空间，还可能为变量定一个初值；<br>变量和声明看是微不足道，但是在多个文件中使用同一个变量，就必须将声明和定义分离。变量定义只能出现在一个文件里，而其他用到该变量的文件必须对其进行声明，却不能重复定义。</p>
<p>2 标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。<br>用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头。</p>
<p>3 引用为对象起了另外一个名字，通过将声明写成&amp;d的形式来定义引用类型，<br>Int &amp;refVal=ival;  int &refVal2; //报错，引用必须被初始化<br>引用类型的初始值必须为一个对象。<br>引用本身不是一个对象，所以不能定义引用的引用，也不能定义指向引用的指针。</p>
<p>4 解引用操作适用于那些确实指向了某个对象的有效指针。<br>空指针实现三种方式：int <em>p1=nullptr; int </em>p2=0; int *p3=0;</p>
<p>5 如果现在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p>
<p>6 constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明constexpr的变量一定是一个常量，而且必须用常量表达式初始化。在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关。<br>Constexpr int *q=nullptr; //q是一个指向整数的常量指针。</p>
<p>7 如果r是一个引用，decltype(r)的结果是引用类型。如果表达式的内容是解引用操作，则decltype得到引用类型(decltype(*p))。decltype((i)) d加上括号，结果将是引用。</p>
<p>8 数组知识：<br>Int a[]={0,1,2}; int a2[]=a; //不允许使用一个数组初始化另一个数组]<br>Int <em>parr[42]; //含有42个整型指针的数组<br>Int (</em>parray)[10]=&arr; //parray指向一个含有10个整数的数组<br>Int (&amp;arrRef)[10]=arr; //arrRef引用一个含有10个整数的数组<br>Int *(&amp;arry)[10]=parr; //arry是数组的引用，该数组还有10个指针</p>
<p>9 vector的数据直接写入(迭代器默认是指针类型)：<br>for(auto beg=v.begin(),end=v.end();beg!=end;++beg){<br>    Auto &amp;r=<em>beg;<br>    r</em>=2;<br>}</p>
<p>10 int i=42;<br>     const int <em>cpi=&i;<br>     Const int &amp;r=i;<br>     Const int &amp;r2=42;<br>     Int </em>p=cp; //错误：p的类型和cp的类型不匹配<br>     Int &amp;r3=r; //错误：r3的类型和r的类型不匹配<br>     Int &amp;r4=42；//错误：不能用字面值初始化一个非常量引用</p>
<p>11 函数指针：bool (<em>pf)(const string &amp;,const string &amp;);<br>     Bool </em>pf(const string &amp;,const string &amp;); pf是一个返回值为bool指针的函数</p>
<p>12 类中的构造函数不能被声明为const，但是字面常量类的构造函数可以是constexpr函数</p>
<p>13 定义在public说明符之后的成员在整个程序可被访问，public成员定义类的接口。<br>     定义在private说明符之后的成员可以被类的成员函数访问，但不能被使用该类的<br>代码访问，private部分封装了类的实现细节。<br>    使用class和struct类定义唯一的区别就是默认的访问权限。</p>
<p>14 友元：友元声明只能出现在类定义的内部，但是在类内部出现的具体位置不限。</p>
<p>15 explicit关键字只允许出现在类内的构造函数声明处。<br>     Sales_data item1(null_book); //正确，直接初始化<br>     Sales_data item2=null_book; //错误，不能将explicit构造函数用于拷贝的初始化过程</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/07/ffmpeg-compile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="决斗者">
      <meta itemprop="description" content="记录学习的点滴，每天一小步">
      <meta itemprop="image" content="/images/yu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="决斗者的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/07/ffmpeg-compile/" class="post-title-link" itemprop="url">FFmpeg源码Android版本编译</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-07 10:26:38 / 修改时间：10:32:59" itemprop="dateCreated datePublished" datetime="2019-06-07T10:26:38+08:00">2019-06-07</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="FFmpeg源码Android版本编译"><a href="#FFmpeg源码Android版本编译" class="headerlink" title="FFmpeg源码Android版本编译"></a>FFmpeg源码Android版本编译</h4><p>好，今天从源码编译下FFmpeg的Android版本。<br>操作系统：Linux ubuntu12.04<br>NDK版本：android-ndk-r103-linux-x86_64.bin<br>ffmpeg版本：ffmpeg-2.6.9</p>
<p>首先编写一个FFmpge编译脚本build_android.sh：</p>
<p>#!/bin/bash<br>make clean<br>export NDK=/usr/ndk/android-ndk-r10e<br>export SYSROOT=$NDK/platforms/android-9/arch-arm/<br>export TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.8/prebuilt/linux-x86_64<br>export CPU=arm<br>export PREFIX=$(pwd)/android/$CPU<br>export ADDI_CFLAGS=”-marm”</p>
<p>./configure –target-os=linux \<br>–prefix=$PREFIX –arch=arm \<br>–disable-doc \<br>–enable-shared \<br>–disable-static \<br>–disable-yasm \<br>–disable-symver \<br>–enable-gpl \<br>–disable-ffmpeg \<br>–disable-ffplay \<br>–disable-ffprobe \<br>–disable-ffserver \<br>–disable-doc \<br>–disable-symver \<br>–cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \<br>–enable-cross-compile \<br>–sysroot=$SYSROOT \<br>–extra-cflags=”-Os -fpic $ADDI_CFLAGS” \<br>–extra-ldflags=”$ADDI_LDFLAGS” \<br>$ADDITIONAL_CONFIGURE_FLAG<br>make clean<br>make<br>make install</p>
<p>并修改文件权限：<br>Sudo chmod 777 build_android.sh</p>
<p>进入build_android.sh所在的目录，执行命令./buidl_android.sh<br>最后会在ffmpeg目录下出现一个android目录，里面有编译完成的so库</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/02/ffmpeg-base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="决斗者">
      <meta itemprop="description" content="记录学习的点滴，每天一小步">
      <meta itemprop="image" content="/images/yu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="决斗者的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/02/ffmpeg-base/" class="post-title-link" itemprop="url">FFmpeg基础知识和常用结构体</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-02 23:17:50 / 修改时间：23:49:26" itemprop="dateCreated datePublished" datetime="2019-06-02T23:17:50+08:00">2019-06-02</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="FFmpeg基础知识和常用结构体"><a href="#FFmpeg基础知识和常用结构体" class="headerlink" title="FFmpeg基础知识和常用结构体"></a>FFmpeg基础知识和常用结构体</h4><p>最近公司要用到FFmpeg的知识，所以看了雷神之前的博客，感触颇深，感谢雷神无私的分享。<br>这里对一些基础结构体做了些记录，视频播放器播放一个互联网上的视频文件，需要经过以下<br>几个步骤：解协议，解封装，解码视音频，视音频同步。如果播放本地文件则不需要解协议，<br>为以下几个步骤：解封装，解码视音频，视音频同步。<br><img src="/2019/06/02/ffmpeg-base/ffmpeg-base1.jpeg" alt="面想对象的设计"></p>
<p>1 解协议的作用，就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网<br>络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输<br>视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，<br>停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。<br>例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。</p>
<p>2 解封装的作用，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩<br>编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经<br>压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装<br>操作后，输出H.264编码的视频码流和AAC编码的音频码流。</p>
<p>3 解码的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的<br>压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。<br>解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压<br>缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，<br>例如PCM数据</p>
<p>4 视音频同步的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频<br>和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。</p>
<p>各大数据结构体之间的关系：<br><img src="/2019/06/02/ffmpeg-base/ffmpeg-base2.jpeg" alt="面想对象的设计"></p>
<p>主要数据结构：</p>
<h2 id="AVFrame是包含码流参数较多的结构体。"><a href="#AVFrame是包含码流参数较多的结构体。" class="headerlink" title="AVFrame是包含码流参数较多的结构体。"></a>AVFrame是包含码流参数较多的结构体。</h2><p>AVFrame结构体一般用于存储原始数据（即非压缩数据，<br>例如对视频来说是YUV，RGB，对音频来说是PCM），此外还包含了一些相关的信息。比如说，解码<br>的时候存储了宏块类型表，QP表，运动矢量表等数据。编码的时候也存储了相关的数据。因此在<br>使用FFMPEG进行码流分析的时候，AVFrame是一个很重要的结构体。</p>
<p>主要变量的作用：<br>uint8_t <em>data[AV_NUM_DATA_POINTERS]：解码后原始数据（对视频来说是YUV，RGB，对音频来说<br>是PCM）<br>int linesize[AV_NUM_DATA_POINTERS]：data中“一行”数据的大小。注意：未必等于图像的宽，一<br>般大于图像的宽。<br>int width, height：视频帧宽和高（1920x1080,1280x720…）<br>int nb_samples：音频的一个AVFrame中可能包含多个音频帧，在此标记包含了几个<br>int format：解码后原始数据类型（YUV420，YUV422，RGB24…）<br>int key_frame：是否是关键帧<br>enum AVPictureType pict_type：帧类型（I,B,P…）<br>AVRational sample_aspect_ratio：宽高比（16:9，4:3…）<br>int64_t pts：显示时间戳<br>int coded_picture_number：编码帧序号<br>int display_picture_number：显示帧序号<br>int8_t </em>qscale_table：QP表<br>uint8_t <em>mbskip_table：跳过宏块表<br>int16_t (</em>motion_val[2])[2]：运动矢量表<br>uint32_t <em>mb_type：宏块类型表<br>short </em>dct_coeff：DCT系数，这个没有提取过<br>int8_t <em>ref_index[2]：运动估计参考帧列表（貌似H.264这种比较新的标准才会涉及到多参考帧）<br>int interlaced_frame：是否是隔行扫描<br>uint8_t motion_subsample_log2：一个宏块中的运动矢量采样个数，取log的<br>1.data[]:<br>对于packed格式的数据（例如RGB24），会存到data[0]里面。<br>对于planar格式的数据（例如YUV420P），则会分开成data[0]，data[1]，data[2]…（YUV420P中<br>data[0]存Y，data[1]存U，data[2]存V)。<br>2.pict_type:<br>enum AVPictureType {<br>    AV_PICTURE_TYPE_NONE = 0, ///&lt; Undefined<br>    AV_PICTURE_TYPE_I,     ///&lt; Intra<br>    AV_PICTURE_TYPE_P,     ///&lt; Predicted<br>    AV_PICTURE_TYPE_B,     ///&lt; Bi-dir predicted<br>    AV_PICTURE_TYPE_S,     ///&lt; S(GMC)-VOP MPEG4<br>    AV_PICTURE_TYPE_SI,    ///&lt; Switching Intra<br>    AV_PICTURE_TYPE_SP,    ///&lt; Switching Predicted<br>    AV_PICTURE_TYPE_BI,    ///&lt; BI type<br>};<br>3.sample_aspect_ratio:<br>宽高比是一个分数，FFMPEG中用AVRational表达分数：<br>typedef struct AVRational{<br>int num; ///&lt; numerator<br>int den; ///&lt; denominator<br>} AVRational<br>4.qscale_table:<br>QP表指向一块内存，里面存储的是每个宏块的QP值。宏块的标号是从左往右，一行一行的来的。每个宏块<br>对应1个QP。<br>qscale_table[0]就是第1行第1列宏块的QP值；qscale_table[1]就是第1行第2列宏块的QP值；qscale_table[2]<br>就是第1行第3列宏块的QP值。以此类推…<br>5.motion_subsample_log2:<br>1个运动矢量所能代表的画面大小（用宽或者高表示，单位是像素），注意，这里取了log2。<br>即1个运动矢量代表16x16的画面的时候，该值取4；1个运动矢量代表8x8的画面的时候，该值取3…以此类推<br>6.motion_val:<br>运动矢量表存储了一帧视频中的所有运动矢量。<br>int16_t (</em>motion_val[2])[2];<br>7.mb_type:<br>宏块类型表存储了一帧视频中的所有宏块的类型。其存储方式和QP表差不多。只不过其是uint32类型的，而<br>QP表是uint8类型的。每个宏块对应一个宏块类型变量。<br>AVFormatContext是包含码流参数较多的结构体。它是FFMPEG解封装（flv，mp4，rmvb，avi）功能的结构体.<br>struct AVInputFormat <em>iformat：输入数据的封装格式<br>AVIOContext </em>pb：输入数据的缓存<br>unsigned int nb_streams：视音频流的个数<br>AVStream *<em>streams：视音频流<br>char filename[1024]：文件名<br>int64_t duration：时长（单位：微秒us，转换为秒需要除以1000000）<br>int bit_rate：比特率（单位bps，转换为kbps需要除以1000）<br>AVDictionary </em>metadata：元数据<br>视频的原数据（metadata）信息可以通过AVDictionary获取。元数据存储在AVDictionaryEntry结构体中，<br>typedef struct AVDictionaryEntry {<br>char <em>key;<br>char </em>value;<br>} AVDictionaryEntry;</p>
<h2 id="AVCodecContext编解码上下文："><a href="#AVCodecContext编解码上下文：" class="headerlink" title="AVCodecContext编解码上下文："></a>AVCodecContext编解码上下文：</h2><p>enum AVMediaType codec_type：编解码器的类型（视频，音频…）<br>struct AVCodec  <em>codec：采用的解码器AVCodec（H.264,MPEG2…）<br>int bit_rate：平均比特率<br>uint8_t </em>extradata; int extradata_size：针对特定编码器包含的附加信息（例如对于H.264解码器来说，<br>存储SPS，PPS等）<br>AVRational time_base：根据该参数，可以把PTS转化为实际的时间（单位为秒s）<br>int width, height：如果是视频的话，代表宽和高<br>int refs：运动估计参考帧的个数（H.264的话会有多帧，MPEG2这类的一般就没有了）<br>int sample_rate：采样率（音频）<br>int channels：声道数（音频）<br>enum AVSampleFormat sample_fmt：采样格式<br>int profile：型（H.264里面就有，其他编码标准应该也有）</p>
<h2 id="AVIOContext是FFmpeg管理输入输出数据的结构体："><a href="#AVIOContext是FFmpeg管理输入输出数据的结构体：" class="headerlink" title="AVIOContext是FFmpeg管理输入输出数据的结构体："></a>AVIOContext是FFmpeg管理输入输出数据的结构体：</h2><p>unsigned char <em>buffer：缓存开始位置<br>int buffer_size：缓存大小（默认32768）<br>unsigned char </em>buf_ptr：当前指针读取到的位置<br>unsigned char <em>buf_end：缓存结束的位置<br>void </em>opaque：URLContext结构体</p>
<h2 id="AVCodec是存储编解码器信息的结构体："><a href="#AVCodec是存储编解码器信息的结构体：" class="headerlink" title="AVCodec是存储编解码器信息的结构体："></a>AVCodec是存储编解码器信息的结构体：</h2><p>const char <em>name：编解码器的名字，比较短<br>const char </em>long_name：编解码器的名字，全称，比较长<br>enum AVMediaType type：指明了类型，是视频，音频，还是字幕<br>enum AVCodecID id：ID，不重复<br>const AVRational <em>supported_framerates：支持的帧率（仅视频）<br>const enum AVPixelFormat </em>pix_fmts：支持的像素格式（仅视频）<br>const int <em>supported_samplerates：支持的采样率（仅音频）<br>const enum AVSampleFormat </em>sample_fmts：支持的采样格式（仅音频）<br>const uint64_t *channel_layouts：支持的声道数（仅音频）<br>int priv_data_size：私有数据的大小</p>
<h2 id="AVStream存储每个视频-音频流信息的结构体："><a href="#AVStream存储每个视频-音频流信息的结构体：" class="headerlink" title="AVStream存储每个视频/音频流信息的结构体："></a>AVStream存储每个视频/音频流信息的结构体：</h2><p>int index：标识该视频/音频流<br>AVCodecContext <em>codec：指向该视频/音频流的AVCodecContext（它们是一一对应的关系）<br>AVRational time_base：时基。通过该值可以把PTS，DTS转化为真正的时间。FFMPEG其他<br>结构体中也有这个字段，但是根据我的经验，只有AVStream中的time_base是可用的。<br>PTS</em>time_base=真正的时间<br>int64_t duration：该视频/音频流长度<br>AVDictionary *metadata：元数据信息<br>AVRational avg_frame_rate：帧率（注：对视频来说，这个挺重要的）<br>AVPacket attached_pic：附带的图片。比如说一些MP3，AAC音频文件附带的专辑封面。</p>
<h2 id="AVPacket是存储压缩编码数据相关信息的结构体："><a href="#AVPacket是存储压缩编码数据相关信息的结构体：" class="headerlink" title="AVPacket是存储压缩编码数据相关信息的结构体："></a>AVPacket是存储压缩编码数据相关信息的结构体：</h2><p>uint8_t *data：压缩编码的数据。<br>int   size：data的大小<br>int64_t pts：显示时间戳<br>int64_t dts：解码时间戳<br>int   stream_index：标识该AVPacket所属的视频/音频流。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/tensorflow-compile1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="决斗者">
      <meta itemprop="description" content="记录学习的点滴，每天一小步">
      <meta itemprop="image" content="/images/yu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="决斗者的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/29/tensorflow-compile1/" class="post-title-link" itemprop="url">TensorFlow源码编译</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-29 20:25:36" itemprop="dateCreated datePublished" datetime="2019-05-29T20:25:36+08:00">2019-05-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-30 00:23:04" itemprop="dateModified" datetime="2019-05-30T00:23:04+08:00">2019-05-30</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="TensorFlow源码编译"><a href="#TensorFlow源码编译" class="headerlink" title="TensorFlow源码编译"></a>TensorFlow源码编译</h4><p>TensorFlow作为Google在AI领域的基础运行环境，如今作为大热门被广泛研究，这里使用Mac对TensorFlow源码进行编译。<br>1 安装必要的软件<br>1.1 安装JDK 8<br>JDK 8 can be downloaded from Oracle’s JDK Page :<br>下载链接: (<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)。" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)。</a><br>Look for “Mac OS X” under “Java SE Development Kit”. This will download a DMG image with an install wizard。<br>1.2 安装Homebrew<br>Install Homebrew on macOS (OS X)，Installing Homebrew is a one-time setup:<br>$ ruby -e “(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a><br>1.3 安装指定版本Bazel<br>安装安装Google自家的编译工具bazel。<br>mac上最好的办法就是直接使用brew安装了(Install Bazel Homebrew Package)<br>brew install bazel<br>You are all set. You can confirm Bazel is installed successfully by running bazel version.<br>You can later upgrade to newer version of Bazel with brew upgrade bazel.<br>由于不同版本的TensorFlow源码对于Bazel版本有自己的要求。<br>可以通过如下方式安装指导版本的Bazel:<br>进入官网: <a href="https://docs.bazel.build/versions/master/install-os-x.html" target="_blank" rel="noopener">https://docs.bazel.build/versions/master/install-os-x.html</a><br>执行命令：<br>Step 1: Install Xcode command line tools<br>Xcode can be downloaded from the Apple Developer Site (this link redirects to their App Store).<br>For objc_<em> and ios_</em> rule support, you must have Xcode 6.1 or later with iOS SDK 8.1 installed on your system.<br>Once Xcode is installed, accept the license agreement for all users with the following command:<br>sudo xcodebuild -license accept</p>
<p>Step 2: Download the Bazel installer<br>Next, download the Bazel binary installer named bazel-<version>-installer-darwin-x86_64.sh<br>from the Bazel releases page on GitHub.</version></p>
<p>Step 3: Run the installer<br>Run the Bazel installer as follows:<br>chmod +x bazel-<version>-installer-darwin-x86_64.sh<br>./bazel-<version>-installer-darwin-x86_64.sh –user<br>The –user flag installs Bazel to the $HOME/bin directory on your system and sets the .bazelrc<br>path to $HOME/.bazelrc. Use the –help command to see additional installation options.<br>Step 4: Set up your environment<br>If you ran the Bazel installer with the –user flag as above, the Bazel executable is installed in your $HOME/bin directory.<br>It’s a good idea to add this directory to your default paths, as follows:<br>export PATH=”PATH:PATH:PATH:HOME/bin”<br>You can also add this command to your ~/.bashrc or ~/.profile file.<br>All set! You can confirm Bazel is installed successfully by running the following command:<br>bazel version</version></version></p>
<p>1.4 Xcode安装<br>由于在Mac编译tensorflow需要Xcode环境。<br>首先打开连接: <a href="https://developer.apple.com/download/more/" target="_blank" rel="noopener">https://developer.apple.com/download/more/</a><br>进入页面:<br><img src="/2019/05/29/tensorflow-compile1/Image1.jpg" alt="面想对象的设计"><br>在搜索框中输入 xcode 回车搜索，如下图所示:<br><img src="/2019/05/29/tensorflow-compile1/Image2.jpg" alt="面想对象的设计"><br>找到所需的版本，点击+打开，查看详情，单击进行下载。<br>解压安装。</p>
<p>2 安装tensorflow<br>2.1 下载官方的tensorflow源码<br>$ git clone <a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">https://github.com/tensorflow/tensorflow</a><br>2.2 配置<br>下载完成之后，在用户目录下生成一个tensorflow的目录，进入这个目录。<br>./configure<br>进行配置，在配置过程中会出现一系列的问题，通常情况下没有特殊的要求，一般全部都选择n。</p>
<p>3 编译<br>配置完成后就是编译过程了，输入下面命令(输入此命令后你会发现你的电脑呼呼作响，并且会花较长时间来编译)：<br>bazel clean –expunge<br>sudo xcode-select -s /Applications/Xcode.app/Contents/Developer 这个选择Xcode的目录很重要<br>sudo xcodebuild -license<br>bazel clean –expunge<br>bazel build -c opt //tensorflow:libtensorflow_cc.so</p>
<p>4 结果<br>最后在bazel-bin的tensorflow下生成libtensorflow_cc.so和libtensorflow_framework.so文件。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/c-language-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="决斗者">
      <meta itemprop="description" content="记录学习的点滴，每天一小步">
      <meta itemprop="image" content="/images/yu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="决斗者的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/18/c-language-learning/" class="post-title-link" itemprop="url">C、C++知识点总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-18 20:25:36 / 修改时间：20:29:33" itemprop="dateCreated datePublished" datetime="2019-05-18T20:25:36+08:00">2019-05-18</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="C、C-知识点总结"><a href="#C、C-知识点总结" class="headerlink" title="C、C++知识点总结"></a>C、C++知识点总结</h4><p><strong>const作用：</strong></p>
<ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针和指针常量；</li>
<li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ol>
<p><strong>const 使用：</strong></p>
<p>// 类class A<br>{<br>private:<br>    const int a;                // 常对象成员，只能在初始化列表赋值<br>public:<br>    // 构造函数<br>    A() : a(0) { };<br>    A(int x) : a(x) { };        // 初始化列表<br>    // const可用于对重载函数的区分<br>    int getValue();             // 普通成员函数<br>    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值<br>};</p>
<p>void function()<br>{<br>    // 对象<br>    A b;                        // 普通对象，可以调用全部成员函数<br>    const A a;                  // 常对象，只能调用常成员函数、更新常成员变量<br>    const A <em>p = &a;            // 常指针<br>    const A &amp;q = a;             // 常引用<br>    // 指针<br>    char greeting[] = “Hello”;<br>    char</em> p1 = greeting;                // 指针变量，指向字符数组变量<br>    const char<em> p2 = greeting;          // 指针变量，指向字符数组常量<br>    char</em> const p3 = greeting;          // 常指针，指向字符数组变量<br>    const char* const p4 = greeting;    // 常指针，指向字符数组常量<br>}</p>
<p>// 函数void function1(const int Var);           // 传递过来的参数在函数内不可变void function2(const char<em> Var);         // 参数指针所指内容为常量void function3(char</em> const Var);         // 参数指针为常指针void function4(const int&amp; Var);          // 引用参数在函数内为常量</p>
<p>// 函数返回值const int function5();      // 返回一个常数const int<em> function6();     // 返回一个指向常量的指针变量，使用：const int </em>p = function6();int<em> const function7();     // 返回一个指向变量的常指针，使用：int</em> const p = function7();</p>
<p><strong>static作用：</strong></p>
<ol>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ol>
<p><strong>this 指针：</strong></p>
<ol>
<li>this?指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给?this?指针，然后调用成员函数，每次成员函数存取数据成员时，都隐含使用?this?指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li>this?指针被隐含地声明为:?ClassName <em>const this，这意味着不能给?this?指针赋值；在?ClassName?类的?const?成员函数中，this?指针的类型为：const ClassName</em> const，这说明不能对?this?指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li>this?并不是一个常规变量，而是个右值，所以不能取得?this?的地址（不能?&amp;this）。</li>
<li>在以下场景中，经常需要显式引用?this?指针：<br>1） 为实现对象的链式引用；<br>2） 为避免对同一对象进行赋值操作；<br>3） 在实现一些数据结构时，如?list。</li>
</ol>
<p><strong>inline 内联函数作用：</strong></p>
<ol>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>
</ol>
<p><strong>inline 使用：</strong><br>// 声明1（加 inline，建议使用）inline int functionName(int first, int second,…);<br>// 声明2（不加 inline）int functionName(int first, int second,…);<br>// 定义inline int functionName(int first, int second,…) {/<em>**</em>/};<br>// 类内定义，隐式内联class A {<br>    int doA() { return 0; }         // 隐式内联<br>}<br>// 类外定义，需要显式内联class A {<br>    int doA();<br>}<br>inline int A::doA() { return 0; }   // 需要显式内联</p>
<p>编译器对 inline 函数的处理步骤：</p>
<ol>
<li>将 inline 函数体复制到 inline 函数调用点处；</li>
<li>为所用 inline 函数中的局部变量分配内存空间；</li>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>
</ol>
<p><strong>优缺点：</strong><br><strong>优点</strong></p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ol>
<p><strong>虚函数（virtual）可以是内联函数（inline）吗？</strong></p>
<ol>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li>inline virtual?唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如?Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ol>
<p><strong>虚函数内联使用：</strong></p>
<p>#include <iostream><br>using namespace std;class Base<br>{<br>public:<br>        inline virtual void who()<br>        {<br>                cout &lt;&lt; “I am Base\n”;<br>        }<br>        virtual ~Base() {}<br>};<br>class Derived : public Base<br>{<br>public:<br>        inline void who()  // 不写inline时隐式内联<br>        {<br>                cout &lt;&lt; “I am Derived\n”;<br>        }<br>};</iostream></p>
<p>int main()<br>{<br>        // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。<br>        Base b;<br>        b.who();<br>        // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。<br>        Base *ptr = new Derived();<br>        ptr-&gt;who();<br>        // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。<br>        delete ptr;<br>        ptr = nullptr;<br>        system(“pause”);<br>        return 0;<br>}</p>
<p><strong>volatile作用：</strong></p>
<ol>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ol>
<p><strong>assert()：</strong><br>断言，是宏，而非函数。assert 宏的原型定义在?&lt;assert.h&gt;（C）、<cassert>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义?NDEBUG?来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt;?之前。</cassert></p>
<p>#define NDEBUG          // 加上这行，则 assert 不可用</p>
<p>#include &lt;assert.h&gt;<br>assert( p != NULL );    // assert 不可用</p>
<p><strong>sizeof()：</strong></p>
<ol>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ol>
<p>#pragma pack(n)<br>设定结构体、联合以及类成员变量以 n 字节方式对齐</p>
<p>#pragma pack(push)  // 保存对齐状态</p>
<p>#pragma pack(4)     // 设定为 4 字节对齐<br>struct test<br>{<br>    char m1;<br>    double m4;<br>    int m3;<br>};</p>
<p>#pragma pack(pop)   // 恢复对齐状态</p>
<p><strong>位域：</strong><br>Bit mode: 2;    // mode 占 2 位<br>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p>
<ol>
<li>位域在内存中的布局是与机器有关的</li>
<li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li>
<li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li>
</ol>
<p><strong>extern “C”：</strong></p>
<ol>
<li>被 extern 限定的函数或变量是 extern 类型的</li>
<li>被?extern “C”?修饰的变量和函数是按照 C 语言方式编译和链接的<br>extern “C”?的作用是让 C++ 编译器将?extern “C”?声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</li>
</ol>
<p>extern “C” 使用：</p>
<p>#ifdef __cplusplus<br>extern “C” {</p>
<p>#endif<br>void <em>memset(void </em>, int, size_t);</p>
<p>#ifdef __cplusplus<br>}</p>
<p>#endif</p>
<p>struct 和 typedef struct：<br>C 中<br>// c<br>typedef struct Student {<br>    int age;<br>} S;<br>等价于// c<br>struct Student {<br>    int age;<br>};<br>typedef struct Student S;<br>此时?S?等价于?struct Student，但两个标识符名称空间不相同。另外还可以定义与?struct Student?不冲突的?void Student() {}。</p>
<p>C++ 中<br>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。<br>一、如果在类标识符空间定义了?struct Student {…};，使用?Student me;?时，编译器将搜索全局标识符表，Student?未找到，则在类标识符内搜索。<br>即表现为可以使用?Student?也可以使用?struct Student，如下：<br>// cpp<br>struct Student {<br>    int age;<br>};<br>void f( Student me );       // 正确，”struct” 关键字可省略<br>二、若定义了与?Student?同名函数之后，则?Student?只代表函数，不代表结构体，如下：<br>typedef struct Student {<br>    int age;<br>} S;</p>
<p>void Student() {}           // 正确，定义后 “Student” 只代表此函数</p>
<p>//void S() {}               // 错误，符号 “S” 已经被定义为一个 “struct Student” 的别名</p>
<p>int main() {<br>    Student();<br>    struct Student me;      // 或者 “S me”;<br>    return 0;<br>}</p>
<p><strong>C++ 中 struct 和 class</strong><br>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。<br><strong>区别</strong><br>最本质的一个区别就是默认的访问控制</p>
<ol>
<li>默认的继承访问权限。struct 是 public 的，class 是 private 的。</li>
<li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li>
</ol>
<p><strong>union 联合</strong><br>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：1. 默认访问控制符为 public</p>
<ol start="2">
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的。</li>
</ol>
<p><strong>union 使用：</strong></p>
<p>#include<iostream><br>union UnionTest {<br>    UnionTest() : i(10) {};<br>    int i;<br>    double d;<br>};<br>static union {<br>    int i;<br>    double d;<br>};<br>int main() {<br>    UnionTest u;<br>    union {<br>        int i;<br>        double d;<br>    };<br>    std::cout &lt;&lt; u.i &lt;&lt; std::endl;  // 输出 UnionTest 联合的 10<br>    ::i = 20;<br>    std::cout &lt;&lt; ::i &lt;&lt; std::endl;  // 输出全局静态匿名联合的 20<br>    i = 30;<br>    std::cout &lt;&lt; i &lt;&lt; std::endl;    // 输出局部匿名联合的 30<br>    return 0;<br>}</iostream></p>
<p><strong>explicit（显式）关键字：</strong></p>
<ol>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但?按语境转换?除外</li>
</ol>
<p><strong>explicit 使用：</strong><br>struct A<br>{<br>        A(int) { }<br>        operator bool() const { return true; }<br>};</p>
<p>struct B<br>{<br>        explicit B(int) {}<br>        explicit operator bool() const { return true; }<br>};</p>
<p>void doA(A a) {}</p>
<p>void doB(B b) {}</p>
<p>int main()<br>{<br>        A a1(1);         // OK：直接初始化<br>        A a2 = 1;            // OK：复制初始化<br>        A a3{ 1 };           // OK：直接列表初始化<br>        A a4 = { 1 };                // OK：复制列表初始化<br>        A a5 = (A)1;         // OK：允许 static_cast 的显式转换<br>        doA(1);                   // OK：允许从 int 到 A 的隐式转换<br>        if (a1);             // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换<br>        bool a6（a1）;         // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换<br>        bool a7 = a1;                // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换<br>        bool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化<br>        B b1(1);         // OK：直接初始化<br>        B b2 = 1;            // 错误：被 explicit 修饰构造函数的对象不可以复制初始化<br>        B b3{ 1 };           // OK：直接列表初始化<br>        B b4 = { 1 };                // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化<br>        B b5 = (B)1;         // OK：允许 static_cast 的显式转换<br>        doB(1);                   // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换<br>        if (b1);             // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换<br>        bool b6(b1);             // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换<br>        bool b7 = b1;                // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换<br>        bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化<br>        return 0;<br>}</bool></bool></p>
<p><strong>friend 友元类和友元函数：</strong></p>
<ol>
<li>能访问私有成员</li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ol>
<p><strong>using 声明</strong><br>一条?using 声明?语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：using namespace_name::name;<br>构造函数的 using 声明在 C++11 中，派生类能够重用其直接基类定义的构造函数。<br>class Derived : Base {<br>public:<br>    using Base::Base;<br>    /<em> … </em>/<br>};<br>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：<br>derived(parms) : base(args) { }</p>
<p>using 指示<br>using 指示?使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：<br>using namespace_name name;</p>
<p><strong>尽量少使用?using 指示?污染命名空间</strong><br>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p>
<p><strong>using 使用：</strong><br>尽量少使用?using 指示using namespace std;<br>应该多使用?using 声明int x;<br>std::cin &gt;&gt; x ;<br>std::cout &lt;&lt; x &lt;&lt; std::endl;<br>或者using std::cin;<br>using std::cout;<br>using std::endl;<br>int x;<br>cin &gt;&gt; x;<br>cout &lt;&lt; x &lt;&lt; endl;</p>
<p><strong>:: 范围解析运算符：</strong><br><strong>分类：</strong></p>
<ol>
<li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ol>
<p><strong>:: 使用:</strong><br>int count = 0;        // 全局（::）的 count<br>class A {<br>public:<br>    static int count; // 类 A 的 count（A::count）<br>};</p>
<p>int main() {<br>    ::count = 1;      // 设置全局的 count 的值为 1<br>    A::count = 2;     // 设置类 A 的 count 为 2<br>    int count = 0;    // 局部的 count<br>    count = 3;        // 设置局部的 count 的值为 3<br>    return 0;<br>}</p>
<p><strong>enum 枚举类型:</strong><br>限定作用域的枚举类型<br>enum class open_modes { input, output, append };<br>不限定作用域的枚举类型<br>enum color { red, yellow, green };<br>enum { floatPrec = 6, doublePrec = 10 };</p>
<p><strong>decltype:</strong><br>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：<br>decltype ( expression )<br>// 尾置返回允许我们在参数列表之后声明返回类型template <typename it><br>auto fcn(It beg, It end) -&gt; decltype(<em>beg)<br>{<br>    // 处理序列<br>    return </em>beg;    // 返回序列中一个元素的引用<br>}<br>// 为了使用模板参数成员，必须用 typenametemplate <typename it><br>auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(<em>beg)&gt;::type<br>{<br>    // 处理序列<br>    return </em>beg;    // 返回序列中一个元素的拷贝<br>}</typename></typename></p>
<p><strong>引用:</strong><br>左值引用<br>常规引用，一般表示对象的身份。右值引用右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。<br>右值引用<br>可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：<br>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。<br>能够更简洁明确地定义泛型函数。<br>引用折叠X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp;?可折叠成?X&amp;X&amp;&amp; &amp;&amp;?可折叠成?X&amp;&amp;</p>
<p><strong>宏:</strong><br>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</p>
<p><strong>成员初始化列表:</strong><br>好处<br>更高效：少了一次调用默认构造函数的过程。有些场合必须要用初始化列表：</p>
<ol>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。</li>
</ol>
<p><strong>initializer_list 列表初始化:</strong><br>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个?std::initializer_list?参数.</p>
<p>#include <iostream></iostream></p>
<p>#include <vector></vector></p>
<p>#include &lt;initializer_list&gt;</p>
<p>template <class t><br>struct S {<br>    std::vector<t> v;<br>    S(std::initializer_list<t> l) : v(l) {<br>         std::cout &lt;&lt; “constructed with a “ &lt;&lt; l.size() &lt;&lt; “-element list\n”;<br>    }<br>    void append(std::initializer_list<t> l) {<br>        v.insert(v.end(), l.begin(), l.end());<br>    }<br>    std::pair<const t*, std::size_t> c_arr() const {<br>        return {&amp;v[0], v.size()};  // 在 return 语句中复制列表初始化<br>                                   // 这不使用 std::initializer_list<br>    }<br>};</const></t></t></t></class></p>
<p>template <typename t><br>void templated_fn(T) {}</typename></p>
<p>int main()<br>{<br>    S<int> s = {1, 2, 3, 4, 5}; // 复制初始化<br>    s.append({6, 7, 8});      // 函数调用中的列表初始化<br>    std::cout &lt;&lt; “The vector size is now “ &lt;&lt; s.c_arr().second &lt;&lt; “ ints:\n”;<br>    for (auto n : s.v)<br>        std::cout &lt;&lt; n &lt;&lt; ‘ ‘;<br>    std::cout &lt;&lt; ‘\n’;<br>    std::cout &lt;&lt; “Range-for over brace-init-list: \n”;<br>    for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作<br>        std::cout &lt;&lt; x &lt;&lt; ‘ ‘;<br>    std::cout &lt;&lt; ‘\n’;<br>    auto al = {10, 11, 12};   // auto 的特殊规则<br>    std::cout &lt;&lt; “The list bound to auto has size() = “ &lt;&lt; al.size() &lt;&lt; ‘\n’;<br>//    templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，<br>                             // 它无类型，故 T 无法推导<br>    templated_fn&lt;std::initializer_list<int>&gt;({1, 2, 3}); // OK<br>    templated_fn&lt;std::vector<int>&gt;({1, 2, 3});           // 也 OK<br>}</int></int></int></p>
<p><strong>面向对象:</strong><br>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。<br><img src="/2019/05/18/c-language-learning/Image.png" alt="面想对象的设计"><br>面向对象三大特征 —— 封装、继承、多态</p>
<p><strong>封装:</strong><br>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p>
<ol>
<li>public?成员：可以被任意实体访问</li>
<li>protected?成员：只允许被子类及本类的成员函数访问</li>
<li>private?成员：只允许被本类的成员函数访问</li>
</ol>
<p><strong>继承:</strong><br>基类（父类）——&gt; 派生类（子类）</p>
<p><strong>多态:</strong></p>
<ol>
<li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。2. 多态是以封装和继承为基础的。<br>C++ 多态分类及实现：<br>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载<br>子类型多态（Subtype Polymorphism，运行期）：虚函数<br>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板<br>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
<p><strong>静态多态（编译期/早绑定）:</strong><br>函数重载<br>class A<br>{<br>public:<br>    void do(int a);<br>    void do(int a, int b);<br>};</p>
<p><strong>动态多态（运行期期/晚绑定）:</strong><br> 虚函数：用 virtual 修饰成员函数，使其成为虚函数<br>注意：</p>
<ol>
<li>普通函数（非类成员函数）不能是虚函数</li>
<li>静态函数（static）不能是虚函数</li>
<li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li>
<li>内联函数不能是表现多态性时的虚函数，解释见：虚函数（virtual）可以是内联函数（inline）吗？<br><strong>动态多态使用:</strong></li>
</ol>
<p>class Shape                     // 形状类<br>{<br>public:<br>    virtual double calcArea()<br>    {<br>        …<br>    }<br>    virtual ~Shape();<br>};<br>class Circle : public Shape     // 圆形类<br>{<br>public:<br>    virtual double calcArea();<br>    …<br>};<br>class Rect : public Shape       // 矩形类<br>{<br>public:<br>    virtual double calcArea();<br>    …<br>};<br>int main()<br>{<br>    Shape <em> shape1 = new Circle(4.0);<br>    Shape </em> shape2 = new Rect(5.0, 6.0);<br>    shape1-&gt;calcArea();         // 调用圆形类里面的方法<br>    shape2-&gt;calcArea();         // 调用矩形类里面的方法<br>    delete shape1;<br>    shape1 = nullptr;<br>    delete shape2;<br>    shape2 = nullptr;<br>    return 0;<br>}</p>
<p><strong>虚析构函数:</strong><br>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。<br>class Shape<br>{<br>public:<br>    Shape();                    // 构造函数不能是虚函数<br>    virtual double calcArea();<br>    virtual ~Shape();           // 虚析构函数<br>};<br>class Circle : public Shape     // 圆形类<br>{<br>public:<br>    virtual double calcArea();<br>    …<br>};<br>int main()<br>{<br>    Shape * shape1 = new Circle(4.0);<br>    shape1-&gt;calcArea();<br>    delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。<br>    shape1 = NULL;<br>    return 0；<br>}</p>
<p><strong>纯虚函数:</strong><br>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。<br>virtual int A() = 0;</p>
<p><strong>虚函数、纯虚函数:</strong></p>
<ol>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li>
<li>虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。 当然大家也可以完成自己的实现。</li>
<li>纯虚函数关注的是接口的统一性，实现由子类完成。带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。</li>
</ol>
<p><strong>虚函数指针、虚函数表:</strong></p>
<ol>
<li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li>
<li>虚函数表：在程序只读数据段（.rodata section，见：目标文件存储结构），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li>
</ol>
<p><strong>虚继承:</strong></p>
<ol>
<li>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</li>
<li>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</li>
<li>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</li>
</ol>
<p><strong>虚继承、虚函数:</strong><br>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）<br>不同之处：<br>虚继承</p>
<ol>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移虚函数<br>虚函数</li>
<li>不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ol>
<p><strong>模板类、成员模板、虚函数:</strong></p>
<ol>
<li>模板类中可以使用虚函数</li>
<li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li>
</ol>
<p><strong>抽象类、接口类、聚合类:</strong><br>抽象类：含有纯虚函数的类<br>接口类：仅含有纯虚函数的抽象类<br>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<br>所有成员都是 public<br>没有定义任何构造函数<br>没有类内初始化<br>没有基类，也没有 virtual 函数</p>
<p><strong>内存分配和管理:</strong><br>malloc、calloc、realloc、alloca</p>
<ol>
<li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li>
<li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li>
<li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li>
<li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li>
</ol>
<p><strong>malloc、free:</strong><br>用于分配、释放内存<br>malloc、free 使用申请内存，确认是否申请成功<br>char <em>str = (char</em>) malloc(100);<br>assert(str != nullptr);<br>释放内存后指针置空<br>free(p);<br>p = nullptr;</p>
<p><strong>new、delete:</strong></p>
<ol>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
</ol>
<p>int main()<br>{<br>    T* t = new T();     // 先内存分配 ，再构造函数<br>    delete t;           // 先析构函数，再内存释放<br>    return 0;<br>}</p>
<p><strong>定位 new:</strong><br>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。<br>new (place_address) type<br>new (place_address) type (initializers)<br>new (place_address) type [size]<br>new (place_address) type [size] { braced initializer list }<br>place_address?是个指针<br>initializers?提供一个（可能为空的）以逗号分隔的初始值列表</p>
<p><strong>如何定义一个只能在堆上（栈上）生成对象的类？</strong><br><strong>只能在堆上</strong><br>方法：将析构函数设置为私有<br>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。<br><strong>只能在栈上</strong><br>方法：将 new 和 delete 重载为私有原<br>因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>
<p><strong>智能指针</strong><br>C++ 标准库（STL）中<br>头文件：#include <memory><br>C++ 98<br>std::auto_ptr<a href="std::string" target="_blank" rel="noopener">std::string</a> ps (new std::string(str))；<br>C++ 11<br>shared_ptr<br>unique_ptr<br>weak_ptr<br>auto_ptr（被 C++11 弃用）</memory></p>
<p>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。<br>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</p>
<p><strong>shared_ptr</strong><br>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁<strong>weak_ptr</strong><br>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题<br><strong>unique_ptr</strong><br>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。unique_ptr 用于取代<br><strong>auto_ptr</strong><br>auto_ptr被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的?std::move?语义，以及其他瑕疵。</p>
<p><strong>强制类型转换运算符:</strong><br><strong>static_cast</strong></p>
<ol>
<li>用于非多态类型的转换</li>
<li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li>
<li>通常用于转换数值数据类型（如 float -&gt; int）</li>
<li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li>
<li>向上转换是一种隐式转换。</li>
</ol>
<p><strong>dynamic_cast</strong></p>
<ol>
<li>用于多态类型的转换</li>
<li>执行行运行时类型检查</li>
<li>只适用于指针或引用对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li>
<li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li>
</ol>
<p><strong>const_cast</strong><br>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</p>
<p><strong>reinterpret_cast</strong></p>
<ol>
<li>用于位的简单重新解释</li>
<li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li>
<li>允许将任何指针转换为任何其他指针类型（如?char<em>?到?int</em>?或?One_class<em>?到?Unrelated_class</em>?之类的转换，但其本身并不安全）</li>
<li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li>
<li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。</li>
<li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li>
</ol>
<p><strong>运行时类型信息 (RTTI)</strong><br><strong>dynamic_cast</strong><br>用于多态类型的转换<br><strong>typeid</strong></p>
<ol>
<li>typeid 运算符允许在运行时确定对象的类型</li>
<li>type_id 返回一个 type_info 对象的引用</li>
<li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li>
<li>只能获取对象的实际类型<br><strong>type_info</strong></li>
<li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li>
<li>头文件：typeinfo<br><strong>typeid、type_info 使用</strong></li>
</ol>
<p>class Flyable                       // 能飞的<br>{<br>public:<br>    virtual void takeoff() = 0;     // 起飞<br>    virtual void land() = 0;        // 降落<br>};<br>class Bird : public Flyable         // 鸟<br>{<br>public:<br>    void foraging() {…}           // 觅食<br>    virtual void takeoff() {…}<br>    virtual void land() {…}<br>};<br>class Plane : public Flyable        // 飞机<br>{<br>public:<br>    void carry() {…}              // 运输<br>    virtual void take off() {…}<br>    virtual void land() {…}<br>};</p>
<p>class type_info<br>{<br>public:<br>    const char* name() const;<br>    bool operator == (const type_info &amp; rhs) const;<br>    bool operator != (const type_info &amp; rhs) const;<br>    int before(const type_info &amp; rhs) const;<br>    virtual ~type_info();<br>private:<br>    …<br>};</p>
<p>class doSomething(Flyable <em>obj)                 // 做些事情<br>{<br>    obj-&gt;takeoff();<br>    cout &lt;&lt; typeid(</em>obj).name() &lt;&lt; endl;        // 输出传入对象类型（”class Bird” or “class Plane”）<br>    if(typeid(<em>obj) == typeid(Bird))            // 判断对象类型<br>    {<br>        Bird </em>bird = dynamic_cast<bird *>(obj); // 对象转化<br>        bird-&gt;foraging();<br>    }<br>    obj-&gt;land();<br>};</bird></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/yu.jpg" alt="决斗者">
            
              <p class="site-author-name" itemprop="name">决斗者</p>
              <div class="site-description motion-element" itemprop="description">记录学习的点滴，每天一小步</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">决斗者</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.1</div>




        






  <div style="display: none;">
   <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277620454'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1277620454%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
    </div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  


</body>
</html>
